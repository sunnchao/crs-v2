// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/Wei-Shaw/sub2api/ent/account"
	"github.com/Wei-Shaw/sub2api/ent/accountgroup"
	"github.com/Wei-Shaw/sub2api/ent/apikey"
	"github.com/Wei-Shaw/sub2api/ent/group"
	"github.com/Wei-Shaw/sub2api/ent/predicate"
	"github.com/Wei-Shaw/sub2api/ent/proxy"
	"github.com/Wei-Shaw/sub2api/ent/redeemcode"
	"github.com/Wei-Shaw/sub2api/ent/setting"
	"github.com/Wei-Shaw/sub2api/ent/user"
	"github.com/Wei-Shaw/sub2api/ent/userallowedgroup"
	"github.com/Wei-Shaw/sub2api/ent/usersubscription"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAccount          = "Account"
	TypeAccountGroup     = "AccountGroup"
	TypeApiKey           = "ApiKey"
	TypeGroup            = "Group"
	TypeProxy            = "Proxy"
	TypeRedeemCode       = "RedeemCode"
	TypeSetting          = "Setting"
	TypeUser             = "User"
	TypeUserAllowedGroup = "UserAllowedGroup"
	TypeUserSubscription = "UserSubscription"
)

// AccountMutation represents an operation that mutates the Account nodes in the graph.
type AccountMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int64
	created_at            *time.Time
	updated_at            *time.Time
	deleted_at            *time.Time
	name                  *string
	platform              *string
	_type                 *string
	credentials           *map[string]interface{}
	extra                 *map[string]interface{}
	proxy_id              *int64
	addproxy_id           *int64
	concurrency           *int
	addconcurrency        *int
	priority              *int
	addpriority           *int
	status                *string
	error_message         *string
	last_used_at          *time.Time
	schedulable           *bool
	rate_limited_at       *time.Time
	rate_limit_reset_at   *time.Time
	overload_until        *time.Time
	session_window_start  *time.Time
	session_window_end    *time.Time
	session_window_status *string
	clearedFields         map[string]struct{}
	groups                map[int64]struct{}
	removedgroups         map[int64]struct{}
	clearedgroups         bool
	done                  bool
	oldValue              func(context.Context) (*Account, error)
	predicates            []predicate.Account
}

var _ ent.Mutation = (*AccountMutation)(nil)

// accountOption allows management of the mutation configuration using functional options.
type accountOption func(*AccountMutation)

// newAccountMutation creates new mutation for the Account entity.
func newAccountMutation(c config, op Op, opts ...accountOption) *AccountMutation {
	m := &AccountMutation{
		config:        c,
		op:            op,
		typ:           TypeAccount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAccountID sets the ID field of the mutation.
func withAccountID(id int64) accountOption {
	return func(m *AccountMutation) {
		var (
			err   error
			once  sync.Once
			value *Account
		)
		m.oldValue = func(ctx context.Context) (*Account, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Account.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAccount sets the old Account of the mutation.
func withAccount(node *Account) accountOption {
	return func(m *AccountMutation) {
		m.oldValue = func(context.Context) (*Account, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AccountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AccountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AccountMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AccountMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Account.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AccountMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AccountMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AccountMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AccountMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AccountMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AccountMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AccountMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AccountMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *AccountMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[account.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *AccountMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[account.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AccountMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, account.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *AccountMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AccountMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AccountMutation) ResetName() {
	m.name = nil
}

// SetPlatform sets the "platform" field.
func (m *AccountMutation) SetPlatform(s string) {
	m.platform = &s
}

// Platform returns the value of the "platform" field in the mutation.
func (m *AccountMutation) Platform() (r string, exists bool) {
	v := m.platform
	if v == nil {
		return
	}
	return *v, true
}

// OldPlatform returns the old "platform" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldPlatform(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlatform is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlatform requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlatform: %w", err)
	}
	return oldValue.Platform, nil
}

// ResetPlatform resets all changes to the "platform" field.
func (m *AccountMutation) ResetPlatform() {
	m.platform = nil
}

// SetType sets the "type" field.
func (m *AccountMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *AccountMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *AccountMutation) ResetType() {
	m._type = nil
}

// SetCredentials sets the "credentials" field.
func (m *AccountMutation) SetCredentials(value map[string]interface{}) {
	m.credentials = &value
}

// Credentials returns the value of the "credentials" field in the mutation.
func (m *AccountMutation) Credentials() (r map[string]interface{}, exists bool) {
	v := m.credentials
	if v == nil {
		return
	}
	return *v, true
}

// OldCredentials returns the old "credentials" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldCredentials(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCredentials is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCredentials requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCredentials: %w", err)
	}
	return oldValue.Credentials, nil
}

// ResetCredentials resets all changes to the "credentials" field.
func (m *AccountMutation) ResetCredentials() {
	m.credentials = nil
}

// SetExtra sets the "extra" field.
func (m *AccountMutation) SetExtra(value map[string]interface{}) {
	m.extra = &value
}

// Extra returns the value of the "extra" field in the mutation.
func (m *AccountMutation) Extra() (r map[string]interface{}, exists bool) {
	v := m.extra
	if v == nil {
		return
	}
	return *v, true
}

// OldExtra returns the old "extra" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldExtra(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtra is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtra requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtra: %w", err)
	}
	return oldValue.Extra, nil
}

// ResetExtra resets all changes to the "extra" field.
func (m *AccountMutation) ResetExtra() {
	m.extra = nil
}

// SetProxyID sets the "proxy_id" field.
func (m *AccountMutation) SetProxyID(i int64) {
	m.proxy_id = &i
	m.addproxy_id = nil
}

// ProxyID returns the value of the "proxy_id" field in the mutation.
func (m *AccountMutation) ProxyID() (r int64, exists bool) {
	v := m.proxy_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProxyID returns the old "proxy_id" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldProxyID(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProxyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProxyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProxyID: %w", err)
	}
	return oldValue.ProxyID, nil
}

// AddProxyID adds i to the "proxy_id" field.
func (m *AccountMutation) AddProxyID(i int64) {
	if m.addproxy_id != nil {
		*m.addproxy_id += i
	} else {
		m.addproxy_id = &i
	}
}

// AddedProxyID returns the value that was added to the "proxy_id" field in this mutation.
func (m *AccountMutation) AddedProxyID() (r int64, exists bool) {
	v := m.addproxy_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearProxyID clears the value of the "proxy_id" field.
func (m *AccountMutation) ClearProxyID() {
	m.proxy_id = nil
	m.addproxy_id = nil
	m.clearedFields[account.FieldProxyID] = struct{}{}
}

// ProxyIDCleared returns if the "proxy_id" field was cleared in this mutation.
func (m *AccountMutation) ProxyIDCleared() bool {
	_, ok := m.clearedFields[account.FieldProxyID]
	return ok
}

// ResetProxyID resets all changes to the "proxy_id" field.
func (m *AccountMutation) ResetProxyID() {
	m.proxy_id = nil
	m.addproxy_id = nil
	delete(m.clearedFields, account.FieldProxyID)
}

// SetConcurrency sets the "concurrency" field.
func (m *AccountMutation) SetConcurrency(i int) {
	m.concurrency = &i
	m.addconcurrency = nil
}

// Concurrency returns the value of the "concurrency" field in the mutation.
func (m *AccountMutation) Concurrency() (r int, exists bool) {
	v := m.concurrency
	if v == nil {
		return
	}
	return *v, true
}

// OldConcurrency returns the old "concurrency" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldConcurrency(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConcurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConcurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConcurrency: %w", err)
	}
	return oldValue.Concurrency, nil
}

// AddConcurrency adds i to the "concurrency" field.
func (m *AccountMutation) AddConcurrency(i int) {
	if m.addconcurrency != nil {
		*m.addconcurrency += i
	} else {
		m.addconcurrency = &i
	}
}

// AddedConcurrency returns the value that was added to the "concurrency" field in this mutation.
func (m *AccountMutation) AddedConcurrency() (r int, exists bool) {
	v := m.addconcurrency
	if v == nil {
		return
	}
	return *v, true
}

// ResetConcurrency resets all changes to the "concurrency" field.
func (m *AccountMutation) ResetConcurrency() {
	m.concurrency = nil
	m.addconcurrency = nil
}

// SetPriority sets the "priority" field.
func (m *AccountMutation) SetPriority(i int) {
	m.priority = &i
	m.addpriority = nil
}

// Priority returns the value of the "priority" field in the mutation.
func (m *AccountMutation) Priority() (r int, exists bool) {
	v := m.priority
	if v == nil {
		return
	}
	return *v, true
}

// OldPriority returns the old "priority" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldPriority(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriority is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriority: %w", err)
	}
	return oldValue.Priority, nil
}

// AddPriority adds i to the "priority" field.
func (m *AccountMutation) AddPriority(i int) {
	if m.addpriority != nil {
		*m.addpriority += i
	} else {
		m.addpriority = &i
	}
}

// AddedPriority returns the value that was added to the "priority" field in this mutation.
func (m *AccountMutation) AddedPriority() (r int, exists bool) {
	v := m.addpriority
	if v == nil {
		return
	}
	return *v, true
}

// ResetPriority resets all changes to the "priority" field.
func (m *AccountMutation) ResetPriority() {
	m.priority = nil
	m.addpriority = nil
}

// SetStatus sets the "status" field.
func (m *AccountMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *AccountMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *AccountMutation) ResetStatus() {
	m.status = nil
}

// SetErrorMessage sets the "error_message" field.
func (m *AccountMutation) SetErrorMessage(s string) {
	m.error_message = &s
}

// ErrorMessage returns the value of the "error_message" field in the mutation.
func (m *AccountMutation) ErrorMessage() (r string, exists bool) {
	v := m.error_message
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorMessage returns the old "error_message" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldErrorMessage(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorMessage: %w", err)
	}
	return oldValue.ErrorMessage, nil
}

// ClearErrorMessage clears the value of the "error_message" field.
func (m *AccountMutation) ClearErrorMessage() {
	m.error_message = nil
	m.clearedFields[account.FieldErrorMessage] = struct{}{}
}

// ErrorMessageCleared returns if the "error_message" field was cleared in this mutation.
func (m *AccountMutation) ErrorMessageCleared() bool {
	_, ok := m.clearedFields[account.FieldErrorMessage]
	return ok
}

// ResetErrorMessage resets all changes to the "error_message" field.
func (m *AccountMutation) ResetErrorMessage() {
	m.error_message = nil
	delete(m.clearedFields, account.FieldErrorMessage)
}

// SetLastUsedAt sets the "last_used_at" field.
func (m *AccountMutation) SetLastUsedAt(t time.Time) {
	m.last_used_at = &t
}

// LastUsedAt returns the value of the "last_used_at" field in the mutation.
func (m *AccountMutation) LastUsedAt() (r time.Time, exists bool) {
	v := m.last_used_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastUsedAt returns the old "last_used_at" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldLastUsedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastUsedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastUsedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastUsedAt: %w", err)
	}
	return oldValue.LastUsedAt, nil
}

// ClearLastUsedAt clears the value of the "last_used_at" field.
func (m *AccountMutation) ClearLastUsedAt() {
	m.last_used_at = nil
	m.clearedFields[account.FieldLastUsedAt] = struct{}{}
}

// LastUsedAtCleared returns if the "last_used_at" field was cleared in this mutation.
func (m *AccountMutation) LastUsedAtCleared() bool {
	_, ok := m.clearedFields[account.FieldLastUsedAt]
	return ok
}

// ResetLastUsedAt resets all changes to the "last_used_at" field.
func (m *AccountMutation) ResetLastUsedAt() {
	m.last_used_at = nil
	delete(m.clearedFields, account.FieldLastUsedAt)
}

// SetSchedulable sets the "schedulable" field.
func (m *AccountMutation) SetSchedulable(b bool) {
	m.schedulable = &b
}

// Schedulable returns the value of the "schedulable" field in the mutation.
func (m *AccountMutation) Schedulable() (r bool, exists bool) {
	v := m.schedulable
	if v == nil {
		return
	}
	return *v, true
}

// OldSchedulable returns the old "schedulable" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldSchedulable(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSchedulable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSchedulable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSchedulable: %w", err)
	}
	return oldValue.Schedulable, nil
}

// ResetSchedulable resets all changes to the "schedulable" field.
func (m *AccountMutation) ResetSchedulable() {
	m.schedulable = nil
}

// SetRateLimitedAt sets the "rate_limited_at" field.
func (m *AccountMutation) SetRateLimitedAt(t time.Time) {
	m.rate_limited_at = &t
}

// RateLimitedAt returns the value of the "rate_limited_at" field in the mutation.
func (m *AccountMutation) RateLimitedAt() (r time.Time, exists bool) {
	v := m.rate_limited_at
	if v == nil {
		return
	}
	return *v, true
}

// OldRateLimitedAt returns the old "rate_limited_at" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldRateLimitedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRateLimitedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRateLimitedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRateLimitedAt: %w", err)
	}
	return oldValue.RateLimitedAt, nil
}

// ClearRateLimitedAt clears the value of the "rate_limited_at" field.
func (m *AccountMutation) ClearRateLimitedAt() {
	m.rate_limited_at = nil
	m.clearedFields[account.FieldRateLimitedAt] = struct{}{}
}

// RateLimitedAtCleared returns if the "rate_limited_at" field was cleared in this mutation.
func (m *AccountMutation) RateLimitedAtCleared() bool {
	_, ok := m.clearedFields[account.FieldRateLimitedAt]
	return ok
}

// ResetRateLimitedAt resets all changes to the "rate_limited_at" field.
func (m *AccountMutation) ResetRateLimitedAt() {
	m.rate_limited_at = nil
	delete(m.clearedFields, account.FieldRateLimitedAt)
}

// SetRateLimitResetAt sets the "rate_limit_reset_at" field.
func (m *AccountMutation) SetRateLimitResetAt(t time.Time) {
	m.rate_limit_reset_at = &t
}

// RateLimitResetAt returns the value of the "rate_limit_reset_at" field in the mutation.
func (m *AccountMutation) RateLimitResetAt() (r time.Time, exists bool) {
	v := m.rate_limit_reset_at
	if v == nil {
		return
	}
	return *v, true
}

// OldRateLimitResetAt returns the old "rate_limit_reset_at" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldRateLimitResetAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRateLimitResetAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRateLimitResetAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRateLimitResetAt: %w", err)
	}
	return oldValue.RateLimitResetAt, nil
}

// ClearRateLimitResetAt clears the value of the "rate_limit_reset_at" field.
func (m *AccountMutation) ClearRateLimitResetAt() {
	m.rate_limit_reset_at = nil
	m.clearedFields[account.FieldRateLimitResetAt] = struct{}{}
}

// RateLimitResetAtCleared returns if the "rate_limit_reset_at" field was cleared in this mutation.
func (m *AccountMutation) RateLimitResetAtCleared() bool {
	_, ok := m.clearedFields[account.FieldRateLimitResetAt]
	return ok
}

// ResetRateLimitResetAt resets all changes to the "rate_limit_reset_at" field.
func (m *AccountMutation) ResetRateLimitResetAt() {
	m.rate_limit_reset_at = nil
	delete(m.clearedFields, account.FieldRateLimitResetAt)
}

// SetOverloadUntil sets the "overload_until" field.
func (m *AccountMutation) SetOverloadUntil(t time.Time) {
	m.overload_until = &t
}

// OverloadUntil returns the value of the "overload_until" field in the mutation.
func (m *AccountMutation) OverloadUntil() (r time.Time, exists bool) {
	v := m.overload_until
	if v == nil {
		return
	}
	return *v, true
}

// OldOverloadUntil returns the old "overload_until" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldOverloadUntil(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOverloadUntil is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOverloadUntil requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOverloadUntil: %w", err)
	}
	return oldValue.OverloadUntil, nil
}

// ClearOverloadUntil clears the value of the "overload_until" field.
func (m *AccountMutation) ClearOverloadUntil() {
	m.overload_until = nil
	m.clearedFields[account.FieldOverloadUntil] = struct{}{}
}

// OverloadUntilCleared returns if the "overload_until" field was cleared in this mutation.
func (m *AccountMutation) OverloadUntilCleared() bool {
	_, ok := m.clearedFields[account.FieldOverloadUntil]
	return ok
}

// ResetOverloadUntil resets all changes to the "overload_until" field.
func (m *AccountMutation) ResetOverloadUntil() {
	m.overload_until = nil
	delete(m.clearedFields, account.FieldOverloadUntil)
}

// SetSessionWindowStart sets the "session_window_start" field.
func (m *AccountMutation) SetSessionWindowStart(t time.Time) {
	m.session_window_start = &t
}

// SessionWindowStart returns the value of the "session_window_start" field in the mutation.
func (m *AccountMutation) SessionWindowStart() (r time.Time, exists bool) {
	v := m.session_window_start
	if v == nil {
		return
	}
	return *v, true
}

// OldSessionWindowStart returns the old "session_window_start" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldSessionWindowStart(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSessionWindowStart is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSessionWindowStart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSessionWindowStart: %w", err)
	}
	return oldValue.SessionWindowStart, nil
}

// ClearSessionWindowStart clears the value of the "session_window_start" field.
func (m *AccountMutation) ClearSessionWindowStart() {
	m.session_window_start = nil
	m.clearedFields[account.FieldSessionWindowStart] = struct{}{}
}

// SessionWindowStartCleared returns if the "session_window_start" field was cleared in this mutation.
func (m *AccountMutation) SessionWindowStartCleared() bool {
	_, ok := m.clearedFields[account.FieldSessionWindowStart]
	return ok
}

// ResetSessionWindowStart resets all changes to the "session_window_start" field.
func (m *AccountMutation) ResetSessionWindowStart() {
	m.session_window_start = nil
	delete(m.clearedFields, account.FieldSessionWindowStart)
}

// SetSessionWindowEnd sets the "session_window_end" field.
func (m *AccountMutation) SetSessionWindowEnd(t time.Time) {
	m.session_window_end = &t
}

// SessionWindowEnd returns the value of the "session_window_end" field in the mutation.
func (m *AccountMutation) SessionWindowEnd() (r time.Time, exists bool) {
	v := m.session_window_end
	if v == nil {
		return
	}
	return *v, true
}

// OldSessionWindowEnd returns the old "session_window_end" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldSessionWindowEnd(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSessionWindowEnd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSessionWindowEnd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSessionWindowEnd: %w", err)
	}
	return oldValue.SessionWindowEnd, nil
}

// ClearSessionWindowEnd clears the value of the "session_window_end" field.
func (m *AccountMutation) ClearSessionWindowEnd() {
	m.session_window_end = nil
	m.clearedFields[account.FieldSessionWindowEnd] = struct{}{}
}

// SessionWindowEndCleared returns if the "session_window_end" field was cleared in this mutation.
func (m *AccountMutation) SessionWindowEndCleared() bool {
	_, ok := m.clearedFields[account.FieldSessionWindowEnd]
	return ok
}

// ResetSessionWindowEnd resets all changes to the "session_window_end" field.
func (m *AccountMutation) ResetSessionWindowEnd() {
	m.session_window_end = nil
	delete(m.clearedFields, account.FieldSessionWindowEnd)
}

// SetSessionWindowStatus sets the "session_window_status" field.
func (m *AccountMutation) SetSessionWindowStatus(s string) {
	m.session_window_status = &s
}

// SessionWindowStatus returns the value of the "session_window_status" field in the mutation.
func (m *AccountMutation) SessionWindowStatus() (r string, exists bool) {
	v := m.session_window_status
	if v == nil {
		return
	}
	return *v, true
}

// OldSessionWindowStatus returns the old "session_window_status" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldSessionWindowStatus(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSessionWindowStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSessionWindowStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSessionWindowStatus: %w", err)
	}
	return oldValue.SessionWindowStatus, nil
}

// ClearSessionWindowStatus clears the value of the "session_window_status" field.
func (m *AccountMutation) ClearSessionWindowStatus() {
	m.session_window_status = nil
	m.clearedFields[account.FieldSessionWindowStatus] = struct{}{}
}

// SessionWindowStatusCleared returns if the "session_window_status" field was cleared in this mutation.
func (m *AccountMutation) SessionWindowStatusCleared() bool {
	_, ok := m.clearedFields[account.FieldSessionWindowStatus]
	return ok
}

// ResetSessionWindowStatus resets all changes to the "session_window_status" field.
func (m *AccountMutation) ResetSessionWindowStatus() {
	m.session_window_status = nil
	delete(m.clearedFields, account.FieldSessionWindowStatus)
}

// AddGroupIDs adds the "groups" edge to the Group entity by ids.
func (m *AccountMutation) AddGroupIDs(ids ...int64) {
	if m.groups == nil {
		m.groups = make(map[int64]struct{})
	}
	for i := range ids {
		m.groups[ids[i]] = struct{}{}
	}
}

// ClearGroups clears the "groups" edge to the Group entity.
func (m *AccountMutation) ClearGroups() {
	m.clearedgroups = true
}

// GroupsCleared reports if the "groups" edge to the Group entity was cleared.
func (m *AccountMutation) GroupsCleared() bool {
	return m.clearedgroups
}

// RemoveGroupIDs removes the "groups" edge to the Group entity by IDs.
func (m *AccountMutation) RemoveGroupIDs(ids ...int64) {
	if m.removedgroups == nil {
		m.removedgroups = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.groups, ids[i])
		m.removedgroups[ids[i]] = struct{}{}
	}
}

// RemovedGroups returns the removed IDs of the "groups" edge to the Group entity.
func (m *AccountMutation) RemovedGroupsIDs() (ids []int64) {
	for id := range m.removedgroups {
		ids = append(ids, id)
	}
	return
}

// GroupsIDs returns the "groups" edge IDs in the mutation.
func (m *AccountMutation) GroupsIDs() (ids []int64) {
	for id := range m.groups {
		ids = append(ids, id)
	}
	return
}

// ResetGroups resets all changes to the "groups" edge.
func (m *AccountMutation) ResetGroups() {
	m.groups = nil
	m.clearedgroups = false
	m.removedgroups = nil
}

// Where appends a list predicates to the AccountMutation builder.
func (m *AccountMutation) Where(ps ...predicate.Account) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AccountMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AccountMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Account, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AccountMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AccountMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Account).
func (m *AccountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AccountMutation) Fields() []string {
	fields := make([]string, 0, 21)
	if m.created_at != nil {
		fields = append(fields, account.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, account.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, account.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, account.FieldName)
	}
	if m.platform != nil {
		fields = append(fields, account.FieldPlatform)
	}
	if m._type != nil {
		fields = append(fields, account.FieldType)
	}
	if m.credentials != nil {
		fields = append(fields, account.FieldCredentials)
	}
	if m.extra != nil {
		fields = append(fields, account.FieldExtra)
	}
	if m.proxy_id != nil {
		fields = append(fields, account.FieldProxyID)
	}
	if m.concurrency != nil {
		fields = append(fields, account.FieldConcurrency)
	}
	if m.priority != nil {
		fields = append(fields, account.FieldPriority)
	}
	if m.status != nil {
		fields = append(fields, account.FieldStatus)
	}
	if m.error_message != nil {
		fields = append(fields, account.FieldErrorMessage)
	}
	if m.last_used_at != nil {
		fields = append(fields, account.FieldLastUsedAt)
	}
	if m.schedulable != nil {
		fields = append(fields, account.FieldSchedulable)
	}
	if m.rate_limited_at != nil {
		fields = append(fields, account.FieldRateLimitedAt)
	}
	if m.rate_limit_reset_at != nil {
		fields = append(fields, account.FieldRateLimitResetAt)
	}
	if m.overload_until != nil {
		fields = append(fields, account.FieldOverloadUntil)
	}
	if m.session_window_start != nil {
		fields = append(fields, account.FieldSessionWindowStart)
	}
	if m.session_window_end != nil {
		fields = append(fields, account.FieldSessionWindowEnd)
	}
	if m.session_window_status != nil {
		fields = append(fields, account.FieldSessionWindowStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AccountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case account.FieldCreatedAt:
		return m.CreatedAt()
	case account.FieldUpdatedAt:
		return m.UpdatedAt()
	case account.FieldDeletedAt:
		return m.DeletedAt()
	case account.FieldName:
		return m.Name()
	case account.FieldPlatform:
		return m.Platform()
	case account.FieldType:
		return m.GetType()
	case account.FieldCredentials:
		return m.Credentials()
	case account.FieldExtra:
		return m.Extra()
	case account.FieldProxyID:
		return m.ProxyID()
	case account.FieldConcurrency:
		return m.Concurrency()
	case account.FieldPriority:
		return m.Priority()
	case account.FieldStatus:
		return m.Status()
	case account.FieldErrorMessage:
		return m.ErrorMessage()
	case account.FieldLastUsedAt:
		return m.LastUsedAt()
	case account.FieldSchedulable:
		return m.Schedulable()
	case account.FieldRateLimitedAt:
		return m.RateLimitedAt()
	case account.FieldRateLimitResetAt:
		return m.RateLimitResetAt()
	case account.FieldOverloadUntil:
		return m.OverloadUntil()
	case account.FieldSessionWindowStart:
		return m.SessionWindowStart()
	case account.FieldSessionWindowEnd:
		return m.SessionWindowEnd()
	case account.FieldSessionWindowStatus:
		return m.SessionWindowStatus()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AccountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case account.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case account.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case account.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case account.FieldName:
		return m.OldName(ctx)
	case account.FieldPlatform:
		return m.OldPlatform(ctx)
	case account.FieldType:
		return m.OldType(ctx)
	case account.FieldCredentials:
		return m.OldCredentials(ctx)
	case account.FieldExtra:
		return m.OldExtra(ctx)
	case account.FieldProxyID:
		return m.OldProxyID(ctx)
	case account.FieldConcurrency:
		return m.OldConcurrency(ctx)
	case account.FieldPriority:
		return m.OldPriority(ctx)
	case account.FieldStatus:
		return m.OldStatus(ctx)
	case account.FieldErrorMessage:
		return m.OldErrorMessage(ctx)
	case account.FieldLastUsedAt:
		return m.OldLastUsedAt(ctx)
	case account.FieldSchedulable:
		return m.OldSchedulable(ctx)
	case account.FieldRateLimitedAt:
		return m.OldRateLimitedAt(ctx)
	case account.FieldRateLimitResetAt:
		return m.OldRateLimitResetAt(ctx)
	case account.FieldOverloadUntil:
		return m.OldOverloadUntil(ctx)
	case account.FieldSessionWindowStart:
		return m.OldSessionWindowStart(ctx)
	case account.FieldSessionWindowEnd:
		return m.OldSessionWindowEnd(ctx)
	case account.FieldSessionWindowStatus:
		return m.OldSessionWindowStatus(ctx)
	}
	return nil, fmt.Errorf("unknown Account field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case account.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case account.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case account.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case account.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case account.FieldPlatform:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlatform(v)
		return nil
	case account.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case account.FieldCredentials:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCredentials(v)
		return nil
	case account.FieldExtra:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtra(v)
		return nil
	case account.FieldProxyID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProxyID(v)
		return nil
	case account.FieldConcurrency:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConcurrency(v)
		return nil
	case account.FieldPriority:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriority(v)
		return nil
	case account.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case account.FieldErrorMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorMessage(v)
		return nil
	case account.FieldLastUsedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastUsedAt(v)
		return nil
	case account.FieldSchedulable:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSchedulable(v)
		return nil
	case account.FieldRateLimitedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRateLimitedAt(v)
		return nil
	case account.FieldRateLimitResetAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRateLimitResetAt(v)
		return nil
	case account.FieldOverloadUntil:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOverloadUntil(v)
		return nil
	case account.FieldSessionWindowStart:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSessionWindowStart(v)
		return nil
	case account.FieldSessionWindowEnd:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSessionWindowEnd(v)
		return nil
	case account.FieldSessionWindowStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSessionWindowStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Account field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AccountMutation) AddedFields() []string {
	var fields []string
	if m.addproxy_id != nil {
		fields = append(fields, account.FieldProxyID)
	}
	if m.addconcurrency != nil {
		fields = append(fields, account.FieldConcurrency)
	}
	if m.addpriority != nil {
		fields = append(fields, account.FieldPriority)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AccountMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case account.FieldProxyID:
		return m.AddedProxyID()
	case account.FieldConcurrency:
		return m.AddedConcurrency()
	case account.FieldPriority:
		return m.AddedPriority()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountMutation) AddField(name string, value ent.Value) error {
	switch name {
	case account.FieldProxyID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProxyID(v)
		return nil
	case account.FieldConcurrency:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddConcurrency(v)
		return nil
	case account.FieldPriority:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPriority(v)
		return nil
	}
	return fmt.Errorf("unknown Account numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AccountMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(account.FieldDeletedAt) {
		fields = append(fields, account.FieldDeletedAt)
	}
	if m.FieldCleared(account.FieldProxyID) {
		fields = append(fields, account.FieldProxyID)
	}
	if m.FieldCleared(account.FieldErrorMessage) {
		fields = append(fields, account.FieldErrorMessage)
	}
	if m.FieldCleared(account.FieldLastUsedAt) {
		fields = append(fields, account.FieldLastUsedAt)
	}
	if m.FieldCleared(account.FieldRateLimitedAt) {
		fields = append(fields, account.FieldRateLimitedAt)
	}
	if m.FieldCleared(account.FieldRateLimitResetAt) {
		fields = append(fields, account.FieldRateLimitResetAt)
	}
	if m.FieldCleared(account.FieldOverloadUntil) {
		fields = append(fields, account.FieldOverloadUntil)
	}
	if m.FieldCleared(account.FieldSessionWindowStart) {
		fields = append(fields, account.FieldSessionWindowStart)
	}
	if m.FieldCleared(account.FieldSessionWindowEnd) {
		fields = append(fields, account.FieldSessionWindowEnd)
	}
	if m.FieldCleared(account.FieldSessionWindowStatus) {
		fields = append(fields, account.FieldSessionWindowStatus)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AccountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AccountMutation) ClearField(name string) error {
	switch name {
	case account.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case account.FieldProxyID:
		m.ClearProxyID()
		return nil
	case account.FieldErrorMessage:
		m.ClearErrorMessage()
		return nil
	case account.FieldLastUsedAt:
		m.ClearLastUsedAt()
		return nil
	case account.FieldRateLimitedAt:
		m.ClearRateLimitedAt()
		return nil
	case account.FieldRateLimitResetAt:
		m.ClearRateLimitResetAt()
		return nil
	case account.FieldOverloadUntil:
		m.ClearOverloadUntil()
		return nil
	case account.FieldSessionWindowStart:
		m.ClearSessionWindowStart()
		return nil
	case account.FieldSessionWindowEnd:
		m.ClearSessionWindowEnd()
		return nil
	case account.FieldSessionWindowStatus:
		m.ClearSessionWindowStatus()
		return nil
	}
	return fmt.Errorf("unknown Account nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AccountMutation) ResetField(name string) error {
	switch name {
	case account.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case account.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case account.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case account.FieldName:
		m.ResetName()
		return nil
	case account.FieldPlatform:
		m.ResetPlatform()
		return nil
	case account.FieldType:
		m.ResetType()
		return nil
	case account.FieldCredentials:
		m.ResetCredentials()
		return nil
	case account.FieldExtra:
		m.ResetExtra()
		return nil
	case account.FieldProxyID:
		m.ResetProxyID()
		return nil
	case account.FieldConcurrency:
		m.ResetConcurrency()
		return nil
	case account.FieldPriority:
		m.ResetPriority()
		return nil
	case account.FieldStatus:
		m.ResetStatus()
		return nil
	case account.FieldErrorMessage:
		m.ResetErrorMessage()
		return nil
	case account.FieldLastUsedAt:
		m.ResetLastUsedAt()
		return nil
	case account.FieldSchedulable:
		m.ResetSchedulable()
		return nil
	case account.FieldRateLimitedAt:
		m.ResetRateLimitedAt()
		return nil
	case account.FieldRateLimitResetAt:
		m.ResetRateLimitResetAt()
		return nil
	case account.FieldOverloadUntil:
		m.ResetOverloadUntil()
		return nil
	case account.FieldSessionWindowStart:
		m.ResetSessionWindowStart()
		return nil
	case account.FieldSessionWindowEnd:
		m.ResetSessionWindowEnd()
		return nil
	case account.FieldSessionWindowStatus:
		m.ResetSessionWindowStatus()
		return nil
	}
	return fmt.Errorf("unknown Account field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AccountMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.groups != nil {
		edges = append(edges, account.EdgeGroups)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AccountMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case account.EdgeGroups:
		ids := make([]ent.Value, 0, len(m.groups))
		for id := range m.groups {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AccountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedgroups != nil {
		edges = append(edges, account.EdgeGroups)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AccountMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case account.EdgeGroups:
		ids := make([]ent.Value, 0, len(m.removedgroups))
		for id := range m.removedgroups {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AccountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedgroups {
		edges = append(edges, account.EdgeGroups)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AccountMutation) EdgeCleared(name string) bool {
	switch name {
	case account.EdgeGroups:
		return m.clearedgroups
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AccountMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Account unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AccountMutation) ResetEdge(name string) error {
	switch name {
	case account.EdgeGroups:
		m.ResetGroups()
		return nil
	}
	return fmt.Errorf("unknown Account edge %s", name)
}

// AccountGroupMutation represents an operation that mutates the AccountGroup nodes in the graph.
type AccountGroupMutation struct {
	config
	op             Op
	typ            string
	priority       *int
	addpriority    *int
	created_at     *time.Time
	clearedFields  map[string]struct{}
	account        *int64
	clearedaccount bool
	group          *int64
	clearedgroup   bool
	done           bool
	oldValue       func(context.Context) (*AccountGroup, error)
	predicates     []predicate.AccountGroup
}

var _ ent.Mutation = (*AccountGroupMutation)(nil)

// accountgroupOption allows management of the mutation configuration using functional options.
type accountgroupOption func(*AccountGroupMutation)

// newAccountGroupMutation creates new mutation for the AccountGroup entity.
func newAccountGroupMutation(c config, op Op, opts ...accountgroupOption) *AccountGroupMutation {
	m := &AccountGroupMutation{
		config:        c,
		op:            op,
		typ:           TypeAccountGroup,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AccountGroupMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AccountGroupMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetAccountID sets the "account_id" field.
func (m *AccountGroupMutation) SetAccountID(i int64) {
	m.account = &i
}

// AccountID returns the value of the "account_id" field in the mutation.
func (m *AccountGroupMutation) AccountID() (r int64, exists bool) {
	v := m.account
	if v == nil {
		return
	}
	return *v, true
}

// ResetAccountID resets all changes to the "account_id" field.
func (m *AccountGroupMutation) ResetAccountID() {
	m.account = nil
}

// SetGroupID sets the "group_id" field.
func (m *AccountGroupMutation) SetGroupID(i int64) {
	m.group = &i
}

// GroupID returns the value of the "group_id" field in the mutation.
func (m *AccountGroupMutation) GroupID() (r int64, exists bool) {
	v := m.group
	if v == nil {
		return
	}
	return *v, true
}

// ResetGroupID resets all changes to the "group_id" field.
func (m *AccountGroupMutation) ResetGroupID() {
	m.group = nil
}

// SetPriority sets the "priority" field.
func (m *AccountGroupMutation) SetPriority(i int) {
	m.priority = &i
	m.addpriority = nil
}

// Priority returns the value of the "priority" field in the mutation.
func (m *AccountGroupMutation) Priority() (r int, exists bool) {
	v := m.priority
	if v == nil {
		return
	}
	return *v, true
}

// AddPriority adds i to the "priority" field.
func (m *AccountGroupMutation) AddPriority(i int) {
	if m.addpriority != nil {
		*m.addpriority += i
	} else {
		m.addpriority = &i
	}
}

// AddedPriority returns the value that was added to the "priority" field in this mutation.
func (m *AccountGroupMutation) AddedPriority() (r int, exists bool) {
	v := m.addpriority
	if v == nil {
		return
	}
	return *v, true
}

// ResetPriority resets all changes to the "priority" field.
func (m *AccountGroupMutation) ResetPriority() {
	m.priority = nil
	m.addpriority = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AccountGroupMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AccountGroupMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AccountGroupMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearAccount clears the "account" edge to the Account entity.
func (m *AccountGroupMutation) ClearAccount() {
	m.clearedaccount = true
	m.clearedFields[accountgroup.FieldAccountID] = struct{}{}
}

// AccountCleared reports if the "account" edge to the Account entity was cleared.
func (m *AccountGroupMutation) AccountCleared() bool {
	return m.clearedaccount
}

// AccountIDs returns the "account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AccountID instead. It exists only for internal usage by the builders.
func (m *AccountGroupMutation) AccountIDs() (ids []int64) {
	if id := m.account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAccount resets all changes to the "account" edge.
func (m *AccountGroupMutation) ResetAccount() {
	m.account = nil
	m.clearedaccount = false
}

// ClearGroup clears the "group" edge to the Group entity.
func (m *AccountGroupMutation) ClearGroup() {
	m.clearedgroup = true
	m.clearedFields[accountgroup.FieldGroupID] = struct{}{}
}

// GroupCleared reports if the "group" edge to the Group entity was cleared.
func (m *AccountGroupMutation) GroupCleared() bool {
	return m.clearedgroup
}

// GroupIDs returns the "group" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GroupID instead. It exists only for internal usage by the builders.
func (m *AccountGroupMutation) GroupIDs() (ids []int64) {
	if id := m.group; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGroup resets all changes to the "group" edge.
func (m *AccountGroupMutation) ResetGroup() {
	m.group = nil
	m.clearedgroup = false
}

// Where appends a list predicates to the AccountGroupMutation builder.
func (m *AccountGroupMutation) Where(ps ...predicate.AccountGroup) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AccountGroupMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AccountGroupMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AccountGroup, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AccountGroupMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AccountGroupMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AccountGroup).
func (m *AccountGroupMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AccountGroupMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.account != nil {
		fields = append(fields, accountgroup.FieldAccountID)
	}
	if m.group != nil {
		fields = append(fields, accountgroup.FieldGroupID)
	}
	if m.priority != nil {
		fields = append(fields, accountgroup.FieldPriority)
	}
	if m.created_at != nil {
		fields = append(fields, accountgroup.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AccountGroupMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case accountgroup.FieldAccountID:
		return m.AccountID()
	case accountgroup.FieldGroupID:
		return m.GroupID()
	case accountgroup.FieldPriority:
		return m.Priority()
	case accountgroup.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AccountGroupMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, errors.New("edge schema AccountGroup does not support getting old values")
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountGroupMutation) SetField(name string, value ent.Value) error {
	switch name {
	case accountgroup.FieldAccountID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountID(v)
		return nil
	case accountgroup.FieldGroupID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroupID(v)
		return nil
	case accountgroup.FieldPriority:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriority(v)
		return nil
	case accountgroup.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AccountGroup field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AccountGroupMutation) AddedFields() []string {
	var fields []string
	if m.addpriority != nil {
		fields = append(fields, accountgroup.FieldPriority)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AccountGroupMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case accountgroup.FieldPriority:
		return m.AddedPriority()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountGroupMutation) AddField(name string, value ent.Value) error {
	switch name {
	case accountgroup.FieldPriority:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPriority(v)
		return nil
	}
	return fmt.Errorf("unknown AccountGroup numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AccountGroupMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AccountGroupMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AccountGroupMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AccountGroup nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AccountGroupMutation) ResetField(name string) error {
	switch name {
	case accountgroup.FieldAccountID:
		m.ResetAccountID()
		return nil
	case accountgroup.FieldGroupID:
		m.ResetGroupID()
		return nil
	case accountgroup.FieldPriority:
		m.ResetPriority()
		return nil
	case accountgroup.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown AccountGroup field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AccountGroupMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.account != nil {
		edges = append(edges, accountgroup.EdgeAccount)
	}
	if m.group != nil {
		edges = append(edges, accountgroup.EdgeGroup)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AccountGroupMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case accountgroup.EdgeAccount:
		if id := m.account; id != nil {
			return []ent.Value{*id}
		}
	case accountgroup.EdgeGroup:
		if id := m.group; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AccountGroupMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AccountGroupMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AccountGroupMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedaccount {
		edges = append(edges, accountgroup.EdgeAccount)
	}
	if m.clearedgroup {
		edges = append(edges, accountgroup.EdgeGroup)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AccountGroupMutation) EdgeCleared(name string) bool {
	switch name {
	case accountgroup.EdgeAccount:
		return m.clearedaccount
	case accountgroup.EdgeGroup:
		return m.clearedgroup
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AccountGroupMutation) ClearEdge(name string) error {
	switch name {
	case accountgroup.EdgeAccount:
		m.ClearAccount()
		return nil
	case accountgroup.EdgeGroup:
		m.ClearGroup()
		return nil
	}
	return fmt.Errorf("unknown AccountGroup unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AccountGroupMutation) ResetEdge(name string) error {
	switch name {
	case accountgroup.EdgeAccount:
		m.ResetAccount()
		return nil
	case accountgroup.EdgeGroup:
		m.ResetGroup()
		return nil
	}
	return fmt.Errorf("unknown AccountGroup edge %s", name)
}

// ApiKeyMutation represents an operation that mutates the ApiKey nodes in the graph.
type ApiKeyMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	key           *string
	name          *string
	status        *string
	clearedFields map[string]struct{}
	user          *int64
	cleareduser   bool
	group         *int64
	clearedgroup  bool
	done          bool
	oldValue      func(context.Context) (*ApiKey, error)
	predicates    []predicate.ApiKey
}

var _ ent.Mutation = (*ApiKeyMutation)(nil)

// apikeyOption allows management of the mutation configuration using functional options.
type apikeyOption func(*ApiKeyMutation)

// newApiKeyMutation creates new mutation for the ApiKey entity.
func newApiKeyMutation(c config, op Op, opts ...apikeyOption) *ApiKeyMutation {
	m := &ApiKeyMutation{
		config:        c,
		op:            op,
		typ:           TypeApiKey,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withApiKeyID sets the ID field of the mutation.
func withApiKeyID(id int64) apikeyOption {
	return func(m *ApiKeyMutation) {
		var (
			err   error
			once  sync.Once
			value *ApiKey
		)
		m.oldValue = func(ctx context.Context) (*ApiKey, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ApiKey.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withApiKey sets the old ApiKey of the mutation.
func withApiKey(node *ApiKey) apikeyOption {
	return func(m *ApiKeyMutation) {
		m.oldValue = func(context.Context) (*ApiKey, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ApiKeyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ApiKeyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ApiKeyMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ApiKeyMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ApiKey.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ApiKeyMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ApiKeyMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ApiKey entity.
// If the ApiKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiKeyMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ApiKeyMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ApiKeyMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ApiKeyMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ApiKey entity.
// If the ApiKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiKeyMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ApiKeyMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ApiKeyMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ApiKeyMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ApiKey entity.
// If the ApiKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiKeyMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ApiKeyMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[apikey.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ApiKeyMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[apikey.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ApiKeyMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, apikey.FieldDeletedAt)
}

// SetUserID sets the "user_id" field.
func (m *ApiKeyMutation) SetUserID(i int64) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *ApiKeyMutation) UserID() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the ApiKey entity.
// If the ApiKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiKeyMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *ApiKeyMutation) ResetUserID() {
	m.user = nil
}

// SetKey sets the "key" field.
func (m *ApiKeyMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *ApiKeyMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the ApiKey entity.
// If the ApiKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiKeyMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *ApiKeyMutation) ResetKey() {
	m.key = nil
}

// SetName sets the "name" field.
func (m *ApiKeyMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ApiKeyMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ApiKey entity.
// If the ApiKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiKeyMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ApiKeyMutation) ResetName() {
	m.name = nil
}

// SetGroupID sets the "group_id" field.
func (m *ApiKeyMutation) SetGroupID(i int64) {
	m.group = &i
}

// GroupID returns the value of the "group_id" field in the mutation.
func (m *ApiKeyMutation) GroupID() (r int64, exists bool) {
	v := m.group
	if v == nil {
		return
	}
	return *v, true
}

// OldGroupID returns the old "group_id" field's value of the ApiKey entity.
// If the ApiKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiKeyMutation) OldGroupID(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGroupID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGroupID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGroupID: %w", err)
	}
	return oldValue.GroupID, nil
}

// ClearGroupID clears the value of the "group_id" field.
func (m *ApiKeyMutation) ClearGroupID() {
	m.group = nil
	m.clearedFields[apikey.FieldGroupID] = struct{}{}
}

// GroupIDCleared returns if the "group_id" field was cleared in this mutation.
func (m *ApiKeyMutation) GroupIDCleared() bool {
	_, ok := m.clearedFields[apikey.FieldGroupID]
	return ok
}

// ResetGroupID resets all changes to the "group_id" field.
func (m *ApiKeyMutation) ResetGroupID() {
	m.group = nil
	delete(m.clearedFields, apikey.FieldGroupID)
}

// SetStatus sets the "status" field.
func (m *ApiKeyMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *ApiKeyMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ApiKey entity.
// If the ApiKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiKeyMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ApiKeyMutation) ResetStatus() {
	m.status = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *ApiKeyMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[apikey.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *ApiKeyMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *ApiKeyMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *ApiKeyMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearGroup clears the "group" edge to the Group entity.
func (m *ApiKeyMutation) ClearGroup() {
	m.clearedgroup = true
	m.clearedFields[apikey.FieldGroupID] = struct{}{}
}

// GroupCleared reports if the "group" edge to the Group entity was cleared.
func (m *ApiKeyMutation) GroupCleared() bool {
	return m.GroupIDCleared() || m.clearedgroup
}

// GroupIDs returns the "group" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GroupID instead. It exists only for internal usage by the builders.
func (m *ApiKeyMutation) GroupIDs() (ids []int64) {
	if id := m.group; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGroup resets all changes to the "group" edge.
func (m *ApiKeyMutation) ResetGroup() {
	m.group = nil
	m.clearedgroup = false
}

// Where appends a list predicates to the ApiKeyMutation builder.
func (m *ApiKeyMutation) Where(ps ...predicate.ApiKey) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ApiKeyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ApiKeyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ApiKey, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ApiKeyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ApiKeyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ApiKey).
func (m *ApiKeyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ApiKeyMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, apikey.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, apikey.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, apikey.FieldDeletedAt)
	}
	if m.user != nil {
		fields = append(fields, apikey.FieldUserID)
	}
	if m.key != nil {
		fields = append(fields, apikey.FieldKey)
	}
	if m.name != nil {
		fields = append(fields, apikey.FieldName)
	}
	if m.group != nil {
		fields = append(fields, apikey.FieldGroupID)
	}
	if m.status != nil {
		fields = append(fields, apikey.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ApiKeyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case apikey.FieldCreatedAt:
		return m.CreatedAt()
	case apikey.FieldUpdatedAt:
		return m.UpdatedAt()
	case apikey.FieldDeletedAt:
		return m.DeletedAt()
	case apikey.FieldUserID:
		return m.UserID()
	case apikey.FieldKey:
		return m.Key()
	case apikey.FieldName:
		return m.Name()
	case apikey.FieldGroupID:
		return m.GroupID()
	case apikey.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ApiKeyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case apikey.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case apikey.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case apikey.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case apikey.FieldUserID:
		return m.OldUserID(ctx)
	case apikey.FieldKey:
		return m.OldKey(ctx)
	case apikey.FieldName:
		return m.OldName(ctx)
	case apikey.FieldGroupID:
		return m.OldGroupID(ctx)
	case apikey.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown ApiKey field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ApiKeyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case apikey.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case apikey.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case apikey.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case apikey.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case apikey.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case apikey.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case apikey.FieldGroupID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroupID(v)
		return nil
	case apikey.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown ApiKey field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ApiKeyMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ApiKeyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ApiKeyMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ApiKey numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ApiKeyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(apikey.FieldDeletedAt) {
		fields = append(fields, apikey.FieldDeletedAt)
	}
	if m.FieldCleared(apikey.FieldGroupID) {
		fields = append(fields, apikey.FieldGroupID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ApiKeyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ApiKeyMutation) ClearField(name string) error {
	switch name {
	case apikey.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case apikey.FieldGroupID:
		m.ClearGroupID()
		return nil
	}
	return fmt.Errorf("unknown ApiKey nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ApiKeyMutation) ResetField(name string) error {
	switch name {
	case apikey.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case apikey.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case apikey.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case apikey.FieldUserID:
		m.ResetUserID()
		return nil
	case apikey.FieldKey:
		m.ResetKey()
		return nil
	case apikey.FieldName:
		m.ResetName()
		return nil
	case apikey.FieldGroupID:
		m.ResetGroupID()
		return nil
	case apikey.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown ApiKey field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ApiKeyMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, apikey.EdgeUser)
	}
	if m.group != nil {
		edges = append(edges, apikey.EdgeGroup)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ApiKeyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case apikey.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case apikey.EdgeGroup:
		if id := m.group; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ApiKeyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ApiKeyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ApiKeyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, apikey.EdgeUser)
	}
	if m.clearedgroup {
		edges = append(edges, apikey.EdgeGroup)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ApiKeyMutation) EdgeCleared(name string) bool {
	switch name {
	case apikey.EdgeUser:
		return m.cleareduser
	case apikey.EdgeGroup:
		return m.clearedgroup
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ApiKeyMutation) ClearEdge(name string) error {
	switch name {
	case apikey.EdgeUser:
		m.ClearUser()
		return nil
	case apikey.EdgeGroup:
		m.ClearGroup()
		return nil
	}
	return fmt.Errorf("unknown ApiKey unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ApiKeyMutation) ResetEdge(name string) error {
	switch name {
	case apikey.EdgeUser:
		m.ResetUser()
		return nil
	case apikey.EdgeGroup:
		m.ResetGroup()
		return nil
	}
	return fmt.Errorf("unknown ApiKey edge %s", name)
}

// GroupMutation represents an operation that mutates the Group nodes in the graph.
type GroupMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int64
	created_at           *time.Time
	updated_at           *time.Time
	deleted_at           *time.Time
	name                 *string
	description          *string
	rate_multiplier      *float64
	addrate_multiplier   *float64
	is_exclusive         *bool
	status               *string
	platform             *string
	subscription_type    *string
	daily_limit_usd      *float64
	adddaily_limit_usd   *float64
	weekly_limit_usd     *float64
	addweekly_limit_usd  *float64
	monthly_limit_usd    *float64
	addmonthly_limit_usd *float64
	clearedFields        map[string]struct{}
	api_keys             map[int64]struct{}
	removedapi_keys      map[int64]struct{}
	clearedapi_keys      bool
	redeem_codes         map[int64]struct{}
	removedredeem_codes  map[int64]struct{}
	clearedredeem_codes  bool
	subscriptions        map[int64]struct{}
	removedsubscriptions map[int64]struct{}
	clearedsubscriptions bool
	accounts             map[int64]struct{}
	removedaccounts      map[int64]struct{}
	clearedaccounts      bool
	allowed_users        map[int64]struct{}
	removedallowed_users map[int64]struct{}
	clearedallowed_users bool
	done                 bool
	oldValue             func(context.Context) (*Group, error)
	predicates           []predicate.Group
}

var _ ent.Mutation = (*GroupMutation)(nil)

// groupOption allows management of the mutation configuration using functional options.
type groupOption func(*GroupMutation)

// newGroupMutation creates new mutation for the Group entity.
func newGroupMutation(c config, op Op, opts ...groupOption) *GroupMutation {
	m := &GroupMutation{
		config:        c,
		op:            op,
		typ:           TypeGroup,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGroupID sets the ID field of the mutation.
func withGroupID(id int64) groupOption {
	return func(m *GroupMutation) {
		var (
			err   error
			once  sync.Once
			value *Group
		)
		m.oldValue = func(ctx context.Context) (*Group, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Group.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGroup sets the old Group of the mutation.
func withGroup(node *Group) groupOption {
	return func(m *GroupMutation) {
		m.oldValue = func(context.Context) (*Group, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GroupMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GroupMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GroupMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GroupMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Group.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *GroupMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GroupMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GroupMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *GroupMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *GroupMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *GroupMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *GroupMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *GroupMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *GroupMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[group.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *GroupMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[group.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *GroupMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, group.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *GroupMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *GroupMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *GroupMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *GroupMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *GroupMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *GroupMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[group.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *GroupMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[group.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *GroupMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, group.FieldDescription)
}

// SetRateMultiplier sets the "rate_multiplier" field.
func (m *GroupMutation) SetRateMultiplier(f float64) {
	m.rate_multiplier = &f
	m.addrate_multiplier = nil
}

// RateMultiplier returns the value of the "rate_multiplier" field in the mutation.
func (m *GroupMutation) RateMultiplier() (r float64, exists bool) {
	v := m.rate_multiplier
	if v == nil {
		return
	}
	return *v, true
}

// OldRateMultiplier returns the old "rate_multiplier" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldRateMultiplier(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRateMultiplier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRateMultiplier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRateMultiplier: %w", err)
	}
	return oldValue.RateMultiplier, nil
}

// AddRateMultiplier adds f to the "rate_multiplier" field.
func (m *GroupMutation) AddRateMultiplier(f float64) {
	if m.addrate_multiplier != nil {
		*m.addrate_multiplier += f
	} else {
		m.addrate_multiplier = &f
	}
}

// AddedRateMultiplier returns the value that was added to the "rate_multiplier" field in this mutation.
func (m *GroupMutation) AddedRateMultiplier() (r float64, exists bool) {
	v := m.addrate_multiplier
	if v == nil {
		return
	}
	return *v, true
}

// ResetRateMultiplier resets all changes to the "rate_multiplier" field.
func (m *GroupMutation) ResetRateMultiplier() {
	m.rate_multiplier = nil
	m.addrate_multiplier = nil
}

// SetIsExclusive sets the "is_exclusive" field.
func (m *GroupMutation) SetIsExclusive(b bool) {
	m.is_exclusive = &b
}

// IsExclusive returns the value of the "is_exclusive" field in the mutation.
func (m *GroupMutation) IsExclusive() (r bool, exists bool) {
	v := m.is_exclusive
	if v == nil {
		return
	}
	return *v, true
}

// OldIsExclusive returns the old "is_exclusive" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldIsExclusive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsExclusive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsExclusive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsExclusive: %w", err)
	}
	return oldValue.IsExclusive, nil
}

// ResetIsExclusive resets all changes to the "is_exclusive" field.
func (m *GroupMutation) ResetIsExclusive() {
	m.is_exclusive = nil
}

// SetStatus sets the "status" field.
func (m *GroupMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *GroupMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *GroupMutation) ResetStatus() {
	m.status = nil
}

// SetPlatform sets the "platform" field.
func (m *GroupMutation) SetPlatform(s string) {
	m.platform = &s
}

// Platform returns the value of the "platform" field in the mutation.
func (m *GroupMutation) Platform() (r string, exists bool) {
	v := m.platform
	if v == nil {
		return
	}
	return *v, true
}

// OldPlatform returns the old "platform" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldPlatform(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlatform is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlatform requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlatform: %w", err)
	}
	return oldValue.Platform, nil
}

// ResetPlatform resets all changes to the "platform" field.
func (m *GroupMutation) ResetPlatform() {
	m.platform = nil
}

// SetSubscriptionType sets the "subscription_type" field.
func (m *GroupMutation) SetSubscriptionType(s string) {
	m.subscription_type = &s
}

// SubscriptionType returns the value of the "subscription_type" field in the mutation.
func (m *GroupMutation) SubscriptionType() (r string, exists bool) {
	v := m.subscription_type
	if v == nil {
		return
	}
	return *v, true
}

// OldSubscriptionType returns the old "subscription_type" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldSubscriptionType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubscriptionType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubscriptionType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubscriptionType: %w", err)
	}
	return oldValue.SubscriptionType, nil
}

// ResetSubscriptionType resets all changes to the "subscription_type" field.
func (m *GroupMutation) ResetSubscriptionType() {
	m.subscription_type = nil
}

// SetDailyLimitUsd sets the "daily_limit_usd" field.
func (m *GroupMutation) SetDailyLimitUsd(f float64) {
	m.daily_limit_usd = &f
	m.adddaily_limit_usd = nil
}

// DailyLimitUsd returns the value of the "daily_limit_usd" field in the mutation.
func (m *GroupMutation) DailyLimitUsd() (r float64, exists bool) {
	v := m.daily_limit_usd
	if v == nil {
		return
	}
	return *v, true
}

// OldDailyLimitUsd returns the old "daily_limit_usd" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldDailyLimitUsd(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDailyLimitUsd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDailyLimitUsd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDailyLimitUsd: %w", err)
	}
	return oldValue.DailyLimitUsd, nil
}

// AddDailyLimitUsd adds f to the "daily_limit_usd" field.
func (m *GroupMutation) AddDailyLimitUsd(f float64) {
	if m.adddaily_limit_usd != nil {
		*m.adddaily_limit_usd += f
	} else {
		m.adddaily_limit_usd = &f
	}
}

// AddedDailyLimitUsd returns the value that was added to the "daily_limit_usd" field in this mutation.
func (m *GroupMutation) AddedDailyLimitUsd() (r float64, exists bool) {
	v := m.adddaily_limit_usd
	if v == nil {
		return
	}
	return *v, true
}

// ClearDailyLimitUsd clears the value of the "daily_limit_usd" field.
func (m *GroupMutation) ClearDailyLimitUsd() {
	m.daily_limit_usd = nil
	m.adddaily_limit_usd = nil
	m.clearedFields[group.FieldDailyLimitUsd] = struct{}{}
}

// DailyLimitUsdCleared returns if the "daily_limit_usd" field was cleared in this mutation.
func (m *GroupMutation) DailyLimitUsdCleared() bool {
	_, ok := m.clearedFields[group.FieldDailyLimitUsd]
	return ok
}

// ResetDailyLimitUsd resets all changes to the "daily_limit_usd" field.
func (m *GroupMutation) ResetDailyLimitUsd() {
	m.daily_limit_usd = nil
	m.adddaily_limit_usd = nil
	delete(m.clearedFields, group.FieldDailyLimitUsd)
}

// SetWeeklyLimitUsd sets the "weekly_limit_usd" field.
func (m *GroupMutation) SetWeeklyLimitUsd(f float64) {
	m.weekly_limit_usd = &f
	m.addweekly_limit_usd = nil
}

// WeeklyLimitUsd returns the value of the "weekly_limit_usd" field in the mutation.
func (m *GroupMutation) WeeklyLimitUsd() (r float64, exists bool) {
	v := m.weekly_limit_usd
	if v == nil {
		return
	}
	return *v, true
}

// OldWeeklyLimitUsd returns the old "weekly_limit_usd" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldWeeklyLimitUsd(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWeeklyLimitUsd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWeeklyLimitUsd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWeeklyLimitUsd: %w", err)
	}
	return oldValue.WeeklyLimitUsd, nil
}

// AddWeeklyLimitUsd adds f to the "weekly_limit_usd" field.
func (m *GroupMutation) AddWeeklyLimitUsd(f float64) {
	if m.addweekly_limit_usd != nil {
		*m.addweekly_limit_usd += f
	} else {
		m.addweekly_limit_usd = &f
	}
}

// AddedWeeklyLimitUsd returns the value that was added to the "weekly_limit_usd" field in this mutation.
func (m *GroupMutation) AddedWeeklyLimitUsd() (r float64, exists bool) {
	v := m.addweekly_limit_usd
	if v == nil {
		return
	}
	return *v, true
}

// ClearWeeklyLimitUsd clears the value of the "weekly_limit_usd" field.
func (m *GroupMutation) ClearWeeklyLimitUsd() {
	m.weekly_limit_usd = nil
	m.addweekly_limit_usd = nil
	m.clearedFields[group.FieldWeeklyLimitUsd] = struct{}{}
}

// WeeklyLimitUsdCleared returns if the "weekly_limit_usd" field was cleared in this mutation.
func (m *GroupMutation) WeeklyLimitUsdCleared() bool {
	_, ok := m.clearedFields[group.FieldWeeklyLimitUsd]
	return ok
}

// ResetWeeklyLimitUsd resets all changes to the "weekly_limit_usd" field.
func (m *GroupMutation) ResetWeeklyLimitUsd() {
	m.weekly_limit_usd = nil
	m.addweekly_limit_usd = nil
	delete(m.clearedFields, group.FieldWeeklyLimitUsd)
}

// SetMonthlyLimitUsd sets the "monthly_limit_usd" field.
func (m *GroupMutation) SetMonthlyLimitUsd(f float64) {
	m.monthly_limit_usd = &f
	m.addmonthly_limit_usd = nil
}

// MonthlyLimitUsd returns the value of the "monthly_limit_usd" field in the mutation.
func (m *GroupMutation) MonthlyLimitUsd() (r float64, exists bool) {
	v := m.monthly_limit_usd
	if v == nil {
		return
	}
	return *v, true
}

// OldMonthlyLimitUsd returns the old "monthly_limit_usd" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldMonthlyLimitUsd(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMonthlyLimitUsd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMonthlyLimitUsd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMonthlyLimitUsd: %w", err)
	}
	return oldValue.MonthlyLimitUsd, nil
}

// AddMonthlyLimitUsd adds f to the "monthly_limit_usd" field.
func (m *GroupMutation) AddMonthlyLimitUsd(f float64) {
	if m.addmonthly_limit_usd != nil {
		*m.addmonthly_limit_usd += f
	} else {
		m.addmonthly_limit_usd = &f
	}
}

// AddedMonthlyLimitUsd returns the value that was added to the "monthly_limit_usd" field in this mutation.
func (m *GroupMutation) AddedMonthlyLimitUsd() (r float64, exists bool) {
	v := m.addmonthly_limit_usd
	if v == nil {
		return
	}
	return *v, true
}

// ClearMonthlyLimitUsd clears the value of the "monthly_limit_usd" field.
func (m *GroupMutation) ClearMonthlyLimitUsd() {
	m.monthly_limit_usd = nil
	m.addmonthly_limit_usd = nil
	m.clearedFields[group.FieldMonthlyLimitUsd] = struct{}{}
}

// MonthlyLimitUsdCleared returns if the "monthly_limit_usd" field was cleared in this mutation.
func (m *GroupMutation) MonthlyLimitUsdCleared() bool {
	_, ok := m.clearedFields[group.FieldMonthlyLimitUsd]
	return ok
}

// ResetMonthlyLimitUsd resets all changes to the "monthly_limit_usd" field.
func (m *GroupMutation) ResetMonthlyLimitUsd() {
	m.monthly_limit_usd = nil
	m.addmonthly_limit_usd = nil
	delete(m.clearedFields, group.FieldMonthlyLimitUsd)
}

// AddAPIKeyIDs adds the "api_keys" edge to the ApiKey entity by ids.
func (m *GroupMutation) AddAPIKeyIDs(ids ...int64) {
	if m.api_keys == nil {
		m.api_keys = make(map[int64]struct{})
	}
	for i := range ids {
		m.api_keys[ids[i]] = struct{}{}
	}
}

// ClearAPIKeys clears the "api_keys" edge to the ApiKey entity.
func (m *GroupMutation) ClearAPIKeys() {
	m.clearedapi_keys = true
}

// APIKeysCleared reports if the "api_keys" edge to the ApiKey entity was cleared.
func (m *GroupMutation) APIKeysCleared() bool {
	return m.clearedapi_keys
}

// RemoveAPIKeyIDs removes the "api_keys" edge to the ApiKey entity by IDs.
func (m *GroupMutation) RemoveAPIKeyIDs(ids ...int64) {
	if m.removedapi_keys == nil {
		m.removedapi_keys = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.api_keys, ids[i])
		m.removedapi_keys[ids[i]] = struct{}{}
	}
}

// RemovedAPIKeys returns the removed IDs of the "api_keys" edge to the ApiKey entity.
func (m *GroupMutation) RemovedAPIKeysIDs() (ids []int64) {
	for id := range m.removedapi_keys {
		ids = append(ids, id)
	}
	return
}

// APIKeysIDs returns the "api_keys" edge IDs in the mutation.
func (m *GroupMutation) APIKeysIDs() (ids []int64) {
	for id := range m.api_keys {
		ids = append(ids, id)
	}
	return
}

// ResetAPIKeys resets all changes to the "api_keys" edge.
func (m *GroupMutation) ResetAPIKeys() {
	m.api_keys = nil
	m.clearedapi_keys = false
	m.removedapi_keys = nil
}

// AddRedeemCodeIDs adds the "redeem_codes" edge to the RedeemCode entity by ids.
func (m *GroupMutation) AddRedeemCodeIDs(ids ...int64) {
	if m.redeem_codes == nil {
		m.redeem_codes = make(map[int64]struct{})
	}
	for i := range ids {
		m.redeem_codes[ids[i]] = struct{}{}
	}
}

// ClearRedeemCodes clears the "redeem_codes" edge to the RedeemCode entity.
func (m *GroupMutation) ClearRedeemCodes() {
	m.clearedredeem_codes = true
}

// RedeemCodesCleared reports if the "redeem_codes" edge to the RedeemCode entity was cleared.
func (m *GroupMutation) RedeemCodesCleared() bool {
	return m.clearedredeem_codes
}

// RemoveRedeemCodeIDs removes the "redeem_codes" edge to the RedeemCode entity by IDs.
func (m *GroupMutation) RemoveRedeemCodeIDs(ids ...int64) {
	if m.removedredeem_codes == nil {
		m.removedredeem_codes = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.redeem_codes, ids[i])
		m.removedredeem_codes[ids[i]] = struct{}{}
	}
}

// RemovedRedeemCodes returns the removed IDs of the "redeem_codes" edge to the RedeemCode entity.
func (m *GroupMutation) RemovedRedeemCodesIDs() (ids []int64) {
	for id := range m.removedredeem_codes {
		ids = append(ids, id)
	}
	return
}

// RedeemCodesIDs returns the "redeem_codes" edge IDs in the mutation.
func (m *GroupMutation) RedeemCodesIDs() (ids []int64) {
	for id := range m.redeem_codes {
		ids = append(ids, id)
	}
	return
}

// ResetRedeemCodes resets all changes to the "redeem_codes" edge.
func (m *GroupMutation) ResetRedeemCodes() {
	m.redeem_codes = nil
	m.clearedredeem_codes = false
	m.removedredeem_codes = nil
}

// AddSubscriptionIDs adds the "subscriptions" edge to the UserSubscription entity by ids.
func (m *GroupMutation) AddSubscriptionIDs(ids ...int64) {
	if m.subscriptions == nil {
		m.subscriptions = make(map[int64]struct{})
	}
	for i := range ids {
		m.subscriptions[ids[i]] = struct{}{}
	}
}

// ClearSubscriptions clears the "subscriptions" edge to the UserSubscription entity.
func (m *GroupMutation) ClearSubscriptions() {
	m.clearedsubscriptions = true
}

// SubscriptionsCleared reports if the "subscriptions" edge to the UserSubscription entity was cleared.
func (m *GroupMutation) SubscriptionsCleared() bool {
	return m.clearedsubscriptions
}

// RemoveSubscriptionIDs removes the "subscriptions" edge to the UserSubscription entity by IDs.
func (m *GroupMutation) RemoveSubscriptionIDs(ids ...int64) {
	if m.removedsubscriptions == nil {
		m.removedsubscriptions = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.subscriptions, ids[i])
		m.removedsubscriptions[ids[i]] = struct{}{}
	}
}

// RemovedSubscriptions returns the removed IDs of the "subscriptions" edge to the UserSubscription entity.
func (m *GroupMutation) RemovedSubscriptionsIDs() (ids []int64) {
	for id := range m.removedsubscriptions {
		ids = append(ids, id)
	}
	return
}

// SubscriptionsIDs returns the "subscriptions" edge IDs in the mutation.
func (m *GroupMutation) SubscriptionsIDs() (ids []int64) {
	for id := range m.subscriptions {
		ids = append(ids, id)
	}
	return
}

// ResetSubscriptions resets all changes to the "subscriptions" edge.
func (m *GroupMutation) ResetSubscriptions() {
	m.subscriptions = nil
	m.clearedsubscriptions = false
	m.removedsubscriptions = nil
}

// AddAccountIDs adds the "accounts" edge to the Account entity by ids.
func (m *GroupMutation) AddAccountIDs(ids ...int64) {
	if m.accounts == nil {
		m.accounts = make(map[int64]struct{})
	}
	for i := range ids {
		m.accounts[ids[i]] = struct{}{}
	}
}

// ClearAccounts clears the "accounts" edge to the Account entity.
func (m *GroupMutation) ClearAccounts() {
	m.clearedaccounts = true
}

// AccountsCleared reports if the "accounts" edge to the Account entity was cleared.
func (m *GroupMutation) AccountsCleared() bool {
	return m.clearedaccounts
}

// RemoveAccountIDs removes the "accounts" edge to the Account entity by IDs.
func (m *GroupMutation) RemoveAccountIDs(ids ...int64) {
	if m.removedaccounts == nil {
		m.removedaccounts = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.accounts, ids[i])
		m.removedaccounts[ids[i]] = struct{}{}
	}
}

// RemovedAccounts returns the removed IDs of the "accounts" edge to the Account entity.
func (m *GroupMutation) RemovedAccountsIDs() (ids []int64) {
	for id := range m.removedaccounts {
		ids = append(ids, id)
	}
	return
}

// AccountsIDs returns the "accounts" edge IDs in the mutation.
func (m *GroupMutation) AccountsIDs() (ids []int64) {
	for id := range m.accounts {
		ids = append(ids, id)
	}
	return
}

// ResetAccounts resets all changes to the "accounts" edge.
func (m *GroupMutation) ResetAccounts() {
	m.accounts = nil
	m.clearedaccounts = false
	m.removedaccounts = nil
}

// AddAllowedUserIDs adds the "allowed_users" edge to the User entity by ids.
func (m *GroupMutation) AddAllowedUserIDs(ids ...int64) {
	if m.allowed_users == nil {
		m.allowed_users = make(map[int64]struct{})
	}
	for i := range ids {
		m.allowed_users[ids[i]] = struct{}{}
	}
}

// ClearAllowedUsers clears the "allowed_users" edge to the User entity.
func (m *GroupMutation) ClearAllowedUsers() {
	m.clearedallowed_users = true
}

// AllowedUsersCleared reports if the "allowed_users" edge to the User entity was cleared.
func (m *GroupMutation) AllowedUsersCleared() bool {
	return m.clearedallowed_users
}

// RemoveAllowedUserIDs removes the "allowed_users" edge to the User entity by IDs.
func (m *GroupMutation) RemoveAllowedUserIDs(ids ...int64) {
	if m.removedallowed_users == nil {
		m.removedallowed_users = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.allowed_users, ids[i])
		m.removedallowed_users[ids[i]] = struct{}{}
	}
}

// RemovedAllowedUsers returns the removed IDs of the "allowed_users" edge to the User entity.
func (m *GroupMutation) RemovedAllowedUsersIDs() (ids []int64) {
	for id := range m.removedallowed_users {
		ids = append(ids, id)
	}
	return
}

// AllowedUsersIDs returns the "allowed_users" edge IDs in the mutation.
func (m *GroupMutation) AllowedUsersIDs() (ids []int64) {
	for id := range m.allowed_users {
		ids = append(ids, id)
	}
	return
}

// ResetAllowedUsers resets all changes to the "allowed_users" edge.
func (m *GroupMutation) ResetAllowedUsers() {
	m.allowed_users = nil
	m.clearedallowed_users = false
	m.removedallowed_users = nil
}

// Where appends a list predicates to the GroupMutation builder.
func (m *GroupMutation) Where(ps ...predicate.Group) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GroupMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GroupMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Group, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GroupMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GroupMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Group).
func (m *GroupMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GroupMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_at != nil {
		fields = append(fields, group.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, group.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, group.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, group.FieldName)
	}
	if m.description != nil {
		fields = append(fields, group.FieldDescription)
	}
	if m.rate_multiplier != nil {
		fields = append(fields, group.FieldRateMultiplier)
	}
	if m.is_exclusive != nil {
		fields = append(fields, group.FieldIsExclusive)
	}
	if m.status != nil {
		fields = append(fields, group.FieldStatus)
	}
	if m.platform != nil {
		fields = append(fields, group.FieldPlatform)
	}
	if m.subscription_type != nil {
		fields = append(fields, group.FieldSubscriptionType)
	}
	if m.daily_limit_usd != nil {
		fields = append(fields, group.FieldDailyLimitUsd)
	}
	if m.weekly_limit_usd != nil {
		fields = append(fields, group.FieldWeeklyLimitUsd)
	}
	if m.monthly_limit_usd != nil {
		fields = append(fields, group.FieldMonthlyLimitUsd)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GroupMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case group.FieldCreatedAt:
		return m.CreatedAt()
	case group.FieldUpdatedAt:
		return m.UpdatedAt()
	case group.FieldDeletedAt:
		return m.DeletedAt()
	case group.FieldName:
		return m.Name()
	case group.FieldDescription:
		return m.Description()
	case group.FieldRateMultiplier:
		return m.RateMultiplier()
	case group.FieldIsExclusive:
		return m.IsExclusive()
	case group.FieldStatus:
		return m.Status()
	case group.FieldPlatform:
		return m.Platform()
	case group.FieldSubscriptionType:
		return m.SubscriptionType()
	case group.FieldDailyLimitUsd:
		return m.DailyLimitUsd()
	case group.FieldWeeklyLimitUsd:
		return m.WeeklyLimitUsd()
	case group.FieldMonthlyLimitUsd:
		return m.MonthlyLimitUsd()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GroupMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case group.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case group.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case group.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case group.FieldName:
		return m.OldName(ctx)
	case group.FieldDescription:
		return m.OldDescription(ctx)
	case group.FieldRateMultiplier:
		return m.OldRateMultiplier(ctx)
	case group.FieldIsExclusive:
		return m.OldIsExclusive(ctx)
	case group.FieldStatus:
		return m.OldStatus(ctx)
	case group.FieldPlatform:
		return m.OldPlatform(ctx)
	case group.FieldSubscriptionType:
		return m.OldSubscriptionType(ctx)
	case group.FieldDailyLimitUsd:
		return m.OldDailyLimitUsd(ctx)
	case group.FieldWeeklyLimitUsd:
		return m.OldWeeklyLimitUsd(ctx)
	case group.FieldMonthlyLimitUsd:
		return m.OldMonthlyLimitUsd(ctx)
	}
	return nil, fmt.Errorf("unknown Group field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GroupMutation) SetField(name string, value ent.Value) error {
	switch name {
	case group.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case group.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case group.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case group.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case group.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case group.FieldRateMultiplier:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRateMultiplier(v)
		return nil
	case group.FieldIsExclusive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsExclusive(v)
		return nil
	case group.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case group.FieldPlatform:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlatform(v)
		return nil
	case group.FieldSubscriptionType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubscriptionType(v)
		return nil
	case group.FieldDailyLimitUsd:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDailyLimitUsd(v)
		return nil
	case group.FieldWeeklyLimitUsd:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWeeklyLimitUsd(v)
		return nil
	case group.FieldMonthlyLimitUsd:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMonthlyLimitUsd(v)
		return nil
	}
	return fmt.Errorf("unknown Group field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GroupMutation) AddedFields() []string {
	var fields []string
	if m.addrate_multiplier != nil {
		fields = append(fields, group.FieldRateMultiplier)
	}
	if m.adddaily_limit_usd != nil {
		fields = append(fields, group.FieldDailyLimitUsd)
	}
	if m.addweekly_limit_usd != nil {
		fields = append(fields, group.FieldWeeklyLimitUsd)
	}
	if m.addmonthly_limit_usd != nil {
		fields = append(fields, group.FieldMonthlyLimitUsd)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GroupMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case group.FieldRateMultiplier:
		return m.AddedRateMultiplier()
	case group.FieldDailyLimitUsd:
		return m.AddedDailyLimitUsd()
	case group.FieldWeeklyLimitUsd:
		return m.AddedWeeklyLimitUsd()
	case group.FieldMonthlyLimitUsd:
		return m.AddedMonthlyLimitUsd()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GroupMutation) AddField(name string, value ent.Value) error {
	switch name {
	case group.FieldRateMultiplier:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRateMultiplier(v)
		return nil
	case group.FieldDailyLimitUsd:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDailyLimitUsd(v)
		return nil
	case group.FieldWeeklyLimitUsd:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWeeklyLimitUsd(v)
		return nil
	case group.FieldMonthlyLimitUsd:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMonthlyLimitUsd(v)
		return nil
	}
	return fmt.Errorf("unknown Group numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GroupMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(group.FieldDeletedAt) {
		fields = append(fields, group.FieldDeletedAt)
	}
	if m.FieldCleared(group.FieldDescription) {
		fields = append(fields, group.FieldDescription)
	}
	if m.FieldCleared(group.FieldDailyLimitUsd) {
		fields = append(fields, group.FieldDailyLimitUsd)
	}
	if m.FieldCleared(group.FieldWeeklyLimitUsd) {
		fields = append(fields, group.FieldWeeklyLimitUsd)
	}
	if m.FieldCleared(group.FieldMonthlyLimitUsd) {
		fields = append(fields, group.FieldMonthlyLimitUsd)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GroupMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GroupMutation) ClearField(name string) error {
	switch name {
	case group.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case group.FieldDescription:
		m.ClearDescription()
		return nil
	case group.FieldDailyLimitUsd:
		m.ClearDailyLimitUsd()
		return nil
	case group.FieldWeeklyLimitUsd:
		m.ClearWeeklyLimitUsd()
		return nil
	case group.FieldMonthlyLimitUsd:
		m.ClearMonthlyLimitUsd()
		return nil
	}
	return fmt.Errorf("unknown Group nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GroupMutation) ResetField(name string) error {
	switch name {
	case group.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case group.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case group.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case group.FieldName:
		m.ResetName()
		return nil
	case group.FieldDescription:
		m.ResetDescription()
		return nil
	case group.FieldRateMultiplier:
		m.ResetRateMultiplier()
		return nil
	case group.FieldIsExclusive:
		m.ResetIsExclusive()
		return nil
	case group.FieldStatus:
		m.ResetStatus()
		return nil
	case group.FieldPlatform:
		m.ResetPlatform()
		return nil
	case group.FieldSubscriptionType:
		m.ResetSubscriptionType()
		return nil
	case group.FieldDailyLimitUsd:
		m.ResetDailyLimitUsd()
		return nil
	case group.FieldWeeklyLimitUsd:
		m.ResetWeeklyLimitUsd()
		return nil
	case group.FieldMonthlyLimitUsd:
		m.ResetMonthlyLimitUsd()
		return nil
	}
	return fmt.Errorf("unknown Group field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GroupMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.api_keys != nil {
		edges = append(edges, group.EdgeAPIKeys)
	}
	if m.redeem_codes != nil {
		edges = append(edges, group.EdgeRedeemCodes)
	}
	if m.subscriptions != nil {
		edges = append(edges, group.EdgeSubscriptions)
	}
	if m.accounts != nil {
		edges = append(edges, group.EdgeAccounts)
	}
	if m.allowed_users != nil {
		edges = append(edges, group.EdgeAllowedUsers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GroupMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case group.EdgeAPIKeys:
		ids := make([]ent.Value, 0, len(m.api_keys))
		for id := range m.api_keys {
			ids = append(ids, id)
		}
		return ids
	case group.EdgeRedeemCodes:
		ids := make([]ent.Value, 0, len(m.redeem_codes))
		for id := range m.redeem_codes {
			ids = append(ids, id)
		}
		return ids
	case group.EdgeSubscriptions:
		ids := make([]ent.Value, 0, len(m.subscriptions))
		for id := range m.subscriptions {
			ids = append(ids, id)
		}
		return ids
	case group.EdgeAccounts:
		ids := make([]ent.Value, 0, len(m.accounts))
		for id := range m.accounts {
			ids = append(ids, id)
		}
		return ids
	case group.EdgeAllowedUsers:
		ids := make([]ent.Value, 0, len(m.allowed_users))
		for id := range m.allowed_users {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GroupMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedapi_keys != nil {
		edges = append(edges, group.EdgeAPIKeys)
	}
	if m.removedredeem_codes != nil {
		edges = append(edges, group.EdgeRedeemCodes)
	}
	if m.removedsubscriptions != nil {
		edges = append(edges, group.EdgeSubscriptions)
	}
	if m.removedaccounts != nil {
		edges = append(edges, group.EdgeAccounts)
	}
	if m.removedallowed_users != nil {
		edges = append(edges, group.EdgeAllowedUsers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GroupMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case group.EdgeAPIKeys:
		ids := make([]ent.Value, 0, len(m.removedapi_keys))
		for id := range m.removedapi_keys {
			ids = append(ids, id)
		}
		return ids
	case group.EdgeRedeemCodes:
		ids := make([]ent.Value, 0, len(m.removedredeem_codes))
		for id := range m.removedredeem_codes {
			ids = append(ids, id)
		}
		return ids
	case group.EdgeSubscriptions:
		ids := make([]ent.Value, 0, len(m.removedsubscriptions))
		for id := range m.removedsubscriptions {
			ids = append(ids, id)
		}
		return ids
	case group.EdgeAccounts:
		ids := make([]ent.Value, 0, len(m.removedaccounts))
		for id := range m.removedaccounts {
			ids = append(ids, id)
		}
		return ids
	case group.EdgeAllowedUsers:
		ids := make([]ent.Value, 0, len(m.removedallowed_users))
		for id := range m.removedallowed_users {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GroupMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedapi_keys {
		edges = append(edges, group.EdgeAPIKeys)
	}
	if m.clearedredeem_codes {
		edges = append(edges, group.EdgeRedeemCodes)
	}
	if m.clearedsubscriptions {
		edges = append(edges, group.EdgeSubscriptions)
	}
	if m.clearedaccounts {
		edges = append(edges, group.EdgeAccounts)
	}
	if m.clearedallowed_users {
		edges = append(edges, group.EdgeAllowedUsers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GroupMutation) EdgeCleared(name string) bool {
	switch name {
	case group.EdgeAPIKeys:
		return m.clearedapi_keys
	case group.EdgeRedeemCodes:
		return m.clearedredeem_codes
	case group.EdgeSubscriptions:
		return m.clearedsubscriptions
	case group.EdgeAccounts:
		return m.clearedaccounts
	case group.EdgeAllowedUsers:
		return m.clearedallowed_users
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GroupMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Group unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GroupMutation) ResetEdge(name string) error {
	switch name {
	case group.EdgeAPIKeys:
		m.ResetAPIKeys()
		return nil
	case group.EdgeRedeemCodes:
		m.ResetRedeemCodes()
		return nil
	case group.EdgeSubscriptions:
		m.ResetSubscriptions()
		return nil
	case group.EdgeAccounts:
		m.ResetAccounts()
		return nil
	case group.EdgeAllowedUsers:
		m.ResetAllowedUsers()
		return nil
	}
	return fmt.Errorf("unknown Group edge %s", name)
}

// ProxyMutation represents an operation that mutates the Proxy nodes in the graph.
type ProxyMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	name          *string
	protocol      *string
	host          *string
	port          *int
	addport       *int
	username      *string
	password      *string
	status        *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Proxy, error)
	predicates    []predicate.Proxy
}

var _ ent.Mutation = (*ProxyMutation)(nil)

// proxyOption allows management of the mutation configuration using functional options.
type proxyOption func(*ProxyMutation)

// newProxyMutation creates new mutation for the Proxy entity.
func newProxyMutation(c config, op Op, opts ...proxyOption) *ProxyMutation {
	m := &ProxyMutation{
		config:        c,
		op:            op,
		typ:           TypeProxy,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProxyID sets the ID field of the mutation.
func withProxyID(id int64) proxyOption {
	return func(m *ProxyMutation) {
		var (
			err   error
			once  sync.Once
			value *Proxy
		)
		m.oldValue = func(ctx context.Context) (*Proxy, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Proxy.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProxy sets the old Proxy of the mutation.
func withProxy(node *Proxy) proxyOption {
	return func(m *ProxyMutation) {
		m.oldValue = func(context.Context) (*Proxy, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProxyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProxyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProxyMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProxyMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Proxy.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ProxyMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProxyMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Proxy entity.
// If the Proxy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProxyMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProxyMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProxyMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProxyMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Proxy entity.
// If the Proxy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProxyMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProxyMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ProxyMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ProxyMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Proxy entity.
// If the Proxy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProxyMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ProxyMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[proxy.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ProxyMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[proxy.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ProxyMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, proxy.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *ProxyMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProxyMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Proxy entity.
// If the Proxy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProxyMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProxyMutation) ResetName() {
	m.name = nil
}

// SetProtocol sets the "protocol" field.
func (m *ProxyMutation) SetProtocol(s string) {
	m.protocol = &s
}

// Protocol returns the value of the "protocol" field in the mutation.
func (m *ProxyMutation) Protocol() (r string, exists bool) {
	v := m.protocol
	if v == nil {
		return
	}
	return *v, true
}

// OldProtocol returns the old "protocol" field's value of the Proxy entity.
// If the Proxy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProxyMutation) OldProtocol(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProtocol is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProtocol requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProtocol: %w", err)
	}
	return oldValue.Protocol, nil
}

// ResetProtocol resets all changes to the "protocol" field.
func (m *ProxyMutation) ResetProtocol() {
	m.protocol = nil
}

// SetHost sets the "host" field.
func (m *ProxyMutation) SetHost(s string) {
	m.host = &s
}

// Host returns the value of the "host" field in the mutation.
func (m *ProxyMutation) Host() (r string, exists bool) {
	v := m.host
	if v == nil {
		return
	}
	return *v, true
}

// OldHost returns the old "host" field's value of the Proxy entity.
// If the Proxy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProxyMutation) OldHost(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHost: %w", err)
	}
	return oldValue.Host, nil
}

// ResetHost resets all changes to the "host" field.
func (m *ProxyMutation) ResetHost() {
	m.host = nil
}

// SetPort sets the "port" field.
func (m *ProxyMutation) SetPort(i int) {
	m.port = &i
	m.addport = nil
}

// Port returns the value of the "port" field in the mutation.
func (m *ProxyMutation) Port() (r int, exists bool) {
	v := m.port
	if v == nil {
		return
	}
	return *v, true
}

// OldPort returns the old "port" field's value of the Proxy entity.
// If the Proxy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProxyMutation) OldPort(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPort: %w", err)
	}
	return oldValue.Port, nil
}

// AddPort adds i to the "port" field.
func (m *ProxyMutation) AddPort(i int) {
	if m.addport != nil {
		*m.addport += i
	} else {
		m.addport = &i
	}
}

// AddedPort returns the value that was added to the "port" field in this mutation.
func (m *ProxyMutation) AddedPort() (r int, exists bool) {
	v := m.addport
	if v == nil {
		return
	}
	return *v, true
}

// ResetPort resets all changes to the "port" field.
func (m *ProxyMutation) ResetPort() {
	m.port = nil
	m.addport = nil
}

// SetUsername sets the "username" field.
func (m *ProxyMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *ProxyMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the Proxy entity.
// If the Proxy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProxyMutation) OldUsername(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ClearUsername clears the value of the "username" field.
func (m *ProxyMutation) ClearUsername() {
	m.username = nil
	m.clearedFields[proxy.FieldUsername] = struct{}{}
}

// UsernameCleared returns if the "username" field was cleared in this mutation.
func (m *ProxyMutation) UsernameCleared() bool {
	_, ok := m.clearedFields[proxy.FieldUsername]
	return ok
}

// ResetUsername resets all changes to the "username" field.
func (m *ProxyMutation) ResetUsername() {
	m.username = nil
	delete(m.clearedFields, proxy.FieldUsername)
}

// SetPassword sets the "password" field.
func (m *ProxyMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *ProxyMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the Proxy entity.
// If the Proxy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProxyMutation) OldPassword(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ClearPassword clears the value of the "password" field.
func (m *ProxyMutation) ClearPassword() {
	m.password = nil
	m.clearedFields[proxy.FieldPassword] = struct{}{}
}

// PasswordCleared returns if the "password" field was cleared in this mutation.
func (m *ProxyMutation) PasswordCleared() bool {
	_, ok := m.clearedFields[proxy.FieldPassword]
	return ok
}

// ResetPassword resets all changes to the "password" field.
func (m *ProxyMutation) ResetPassword() {
	m.password = nil
	delete(m.clearedFields, proxy.FieldPassword)
}

// SetStatus sets the "status" field.
func (m *ProxyMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *ProxyMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Proxy entity.
// If the Proxy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProxyMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ProxyMutation) ResetStatus() {
	m.status = nil
}

// Where appends a list predicates to the ProxyMutation builder.
func (m *ProxyMutation) Where(ps ...predicate.Proxy) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProxyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProxyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Proxy, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProxyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProxyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Proxy).
func (m *ProxyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProxyMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, proxy.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, proxy.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, proxy.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, proxy.FieldName)
	}
	if m.protocol != nil {
		fields = append(fields, proxy.FieldProtocol)
	}
	if m.host != nil {
		fields = append(fields, proxy.FieldHost)
	}
	if m.port != nil {
		fields = append(fields, proxy.FieldPort)
	}
	if m.username != nil {
		fields = append(fields, proxy.FieldUsername)
	}
	if m.password != nil {
		fields = append(fields, proxy.FieldPassword)
	}
	if m.status != nil {
		fields = append(fields, proxy.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProxyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case proxy.FieldCreatedAt:
		return m.CreatedAt()
	case proxy.FieldUpdatedAt:
		return m.UpdatedAt()
	case proxy.FieldDeletedAt:
		return m.DeletedAt()
	case proxy.FieldName:
		return m.Name()
	case proxy.FieldProtocol:
		return m.Protocol()
	case proxy.FieldHost:
		return m.Host()
	case proxy.FieldPort:
		return m.Port()
	case proxy.FieldUsername:
		return m.Username()
	case proxy.FieldPassword:
		return m.Password()
	case proxy.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProxyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case proxy.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case proxy.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case proxy.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case proxy.FieldName:
		return m.OldName(ctx)
	case proxy.FieldProtocol:
		return m.OldProtocol(ctx)
	case proxy.FieldHost:
		return m.OldHost(ctx)
	case proxy.FieldPort:
		return m.OldPort(ctx)
	case proxy.FieldUsername:
		return m.OldUsername(ctx)
	case proxy.FieldPassword:
		return m.OldPassword(ctx)
	case proxy.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown Proxy field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProxyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case proxy.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case proxy.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case proxy.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case proxy.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case proxy.FieldProtocol:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProtocol(v)
		return nil
	case proxy.FieldHost:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHost(v)
		return nil
	case proxy.FieldPort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPort(v)
		return nil
	case proxy.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case proxy.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case proxy.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Proxy field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProxyMutation) AddedFields() []string {
	var fields []string
	if m.addport != nil {
		fields = append(fields, proxy.FieldPort)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProxyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case proxy.FieldPort:
		return m.AddedPort()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProxyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case proxy.FieldPort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPort(v)
		return nil
	}
	return fmt.Errorf("unknown Proxy numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProxyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(proxy.FieldDeletedAt) {
		fields = append(fields, proxy.FieldDeletedAt)
	}
	if m.FieldCleared(proxy.FieldUsername) {
		fields = append(fields, proxy.FieldUsername)
	}
	if m.FieldCleared(proxy.FieldPassword) {
		fields = append(fields, proxy.FieldPassword)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProxyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProxyMutation) ClearField(name string) error {
	switch name {
	case proxy.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case proxy.FieldUsername:
		m.ClearUsername()
		return nil
	case proxy.FieldPassword:
		m.ClearPassword()
		return nil
	}
	return fmt.Errorf("unknown Proxy nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProxyMutation) ResetField(name string) error {
	switch name {
	case proxy.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case proxy.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case proxy.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case proxy.FieldName:
		m.ResetName()
		return nil
	case proxy.FieldProtocol:
		m.ResetProtocol()
		return nil
	case proxy.FieldHost:
		m.ResetHost()
		return nil
	case proxy.FieldPort:
		m.ResetPort()
		return nil
	case proxy.FieldUsername:
		m.ResetUsername()
		return nil
	case proxy.FieldPassword:
		m.ResetPassword()
		return nil
	case proxy.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown Proxy field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProxyMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProxyMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProxyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProxyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProxyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProxyMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProxyMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Proxy unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProxyMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Proxy edge %s", name)
}

// RedeemCodeMutation represents an operation that mutates the RedeemCode nodes in the graph.
type RedeemCodeMutation struct {
	config
	op               Op
	typ              string
	id               *int64
	code             *string
	_type            *string
	value            *float64
	addvalue         *float64
	status           *string
	used_at          *time.Time
	notes            *string
	created_at       *time.Time
	validity_days    *int
	addvalidity_days *int
	clearedFields    map[string]struct{}
	user             *int64
	cleareduser      bool
	group            *int64
	clearedgroup     bool
	done             bool
	oldValue         func(context.Context) (*RedeemCode, error)
	predicates       []predicate.RedeemCode
}

var _ ent.Mutation = (*RedeemCodeMutation)(nil)

// redeemcodeOption allows management of the mutation configuration using functional options.
type redeemcodeOption func(*RedeemCodeMutation)

// newRedeemCodeMutation creates new mutation for the RedeemCode entity.
func newRedeemCodeMutation(c config, op Op, opts ...redeemcodeOption) *RedeemCodeMutation {
	m := &RedeemCodeMutation{
		config:        c,
		op:            op,
		typ:           TypeRedeemCode,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRedeemCodeID sets the ID field of the mutation.
func withRedeemCodeID(id int64) redeemcodeOption {
	return func(m *RedeemCodeMutation) {
		var (
			err   error
			once  sync.Once
			value *RedeemCode
		)
		m.oldValue = func(ctx context.Context) (*RedeemCode, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RedeemCode.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRedeemCode sets the old RedeemCode of the mutation.
func withRedeemCode(node *RedeemCode) redeemcodeOption {
	return func(m *RedeemCodeMutation) {
		m.oldValue = func(context.Context) (*RedeemCode, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RedeemCodeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RedeemCodeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RedeemCodeMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RedeemCodeMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RedeemCode.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCode sets the "code" field.
func (m *RedeemCodeMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *RedeemCodeMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the RedeemCode entity.
// If the RedeemCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RedeemCodeMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *RedeemCodeMutation) ResetCode() {
	m.code = nil
}

// SetType sets the "type" field.
func (m *RedeemCodeMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *RedeemCodeMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the RedeemCode entity.
// If the RedeemCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RedeemCodeMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *RedeemCodeMutation) ResetType() {
	m._type = nil
}

// SetValue sets the "value" field.
func (m *RedeemCodeMutation) SetValue(f float64) {
	m.value = &f
	m.addvalue = nil
}

// Value returns the value of the "value" field in the mutation.
func (m *RedeemCodeMutation) Value() (r float64, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the RedeemCode entity.
// If the RedeemCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RedeemCodeMutation) OldValue(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// AddValue adds f to the "value" field.
func (m *RedeemCodeMutation) AddValue(f float64) {
	if m.addvalue != nil {
		*m.addvalue += f
	} else {
		m.addvalue = &f
	}
}

// AddedValue returns the value that was added to the "value" field in this mutation.
func (m *RedeemCodeMutation) AddedValue() (r float64, exists bool) {
	v := m.addvalue
	if v == nil {
		return
	}
	return *v, true
}

// ResetValue resets all changes to the "value" field.
func (m *RedeemCodeMutation) ResetValue() {
	m.value = nil
	m.addvalue = nil
}

// SetStatus sets the "status" field.
func (m *RedeemCodeMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *RedeemCodeMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the RedeemCode entity.
// If the RedeemCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RedeemCodeMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *RedeemCodeMutation) ResetStatus() {
	m.status = nil
}

// SetUsedBy sets the "used_by" field.
func (m *RedeemCodeMutation) SetUsedBy(i int64) {
	m.user = &i
}

// UsedBy returns the value of the "used_by" field in the mutation.
func (m *RedeemCodeMutation) UsedBy() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUsedBy returns the old "used_by" field's value of the RedeemCode entity.
// If the RedeemCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RedeemCodeMutation) OldUsedBy(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsedBy: %w", err)
	}
	return oldValue.UsedBy, nil
}

// ClearUsedBy clears the value of the "used_by" field.
func (m *RedeemCodeMutation) ClearUsedBy() {
	m.user = nil
	m.clearedFields[redeemcode.FieldUsedBy] = struct{}{}
}

// UsedByCleared returns if the "used_by" field was cleared in this mutation.
func (m *RedeemCodeMutation) UsedByCleared() bool {
	_, ok := m.clearedFields[redeemcode.FieldUsedBy]
	return ok
}

// ResetUsedBy resets all changes to the "used_by" field.
func (m *RedeemCodeMutation) ResetUsedBy() {
	m.user = nil
	delete(m.clearedFields, redeemcode.FieldUsedBy)
}

// SetUsedAt sets the "used_at" field.
func (m *RedeemCodeMutation) SetUsedAt(t time.Time) {
	m.used_at = &t
}

// UsedAt returns the value of the "used_at" field in the mutation.
func (m *RedeemCodeMutation) UsedAt() (r time.Time, exists bool) {
	v := m.used_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUsedAt returns the old "used_at" field's value of the RedeemCode entity.
// If the RedeemCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RedeemCodeMutation) OldUsedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsedAt: %w", err)
	}
	return oldValue.UsedAt, nil
}

// ClearUsedAt clears the value of the "used_at" field.
func (m *RedeemCodeMutation) ClearUsedAt() {
	m.used_at = nil
	m.clearedFields[redeemcode.FieldUsedAt] = struct{}{}
}

// UsedAtCleared returns if the "used_at" field was cleared in this mutation.
func (m *RedeemCodeMutation) UsedAtCleared() bool {
	_, ok := m.clearedFields[redeemcode.FieldUsedAt]
	return ok
}

// ResetUsedAt resets all changes to the "used_at" field.
func (m *RedeemCodeMutation) ResetUsedAt() {
	m.used_at = nil
	delete(m.clearedFields, redeemcode.FieldUsedAt)
}

// SetNotes sets the "notes" field.
func (m *RedeemCodeMutation) SetNotes(s string) {
	m.notes = &s
}

// Notes returns the value of the "notes" field in the mutation.
func (m *RedeemCodeMutation) Notes() (r string, exists bool) {
	v := m.notes
	if v == nil {
		return
	}
	return *v, true
}

// OldNotes returns the old "notes" field's value of the RedeemCode entity.
// If the RedeemCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RedeemCodeMutation) OldNotes(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotes: %w", err)
	}
	return oldValue.Notes, nil
}

// ClearNotes clears the value of the "notes" field.
func (m *RedeemCodeMutation) ClearNotes() {
	m.notes = nil
	m.clearedFields[redeemcode.FieldNotes] = struct{}{}
}

// NotesCleared returns if the "notes" field was cleared in this mutation.
func (m *RedeemCodeMutation) NotesCleared() bool {
	_, ok := m.clearedFields[redeemcode.FieldNotes]
	return ok
}

// ResetNotes resets all changes to the "notes" field.
func (m *RedeemCodeMutation) ResetNotes() {
	m.notes = nil
	delete(m.clearedFields, redeemcode.FieldNotes)
}

// SetCreatedAt sets the "created_at" field.
func (m *RedeemCodeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RedeemCodeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the RedeemCode entity.
// If the RedeemCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RedeemCodeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RedeemCodeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetGroupID sets the "group_id" field.
func (m *RedeemCodeMutation) SetGroupID(i int64) {
	m.group = &i
}

// GroupID returns the value of the "group_id" field in the mutation.
func (m *RedeemCodeMutation) GroupID() (r int64, exists bool) {
	v := m.group
	if v == nil {
		return
	}
	return *v, true
}

// OldGroupID returns the old "group_id" field's value of the RedeemCode entity.
// If the RedeemCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RedeemCodeMutation) OldGroupID(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGroupID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGroupID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGroupID: %w", err)
	}
	return oldValue.GroupID, nil
}

// ClearGroupID clears the value of the "group_id" field.
func (m *RedeemCodeMutation) ClearGroupID() {
	m.group = nil
	m.clearedFields[redeemcode.FieldGroupID] = struct{}{}
}

// GroupIDCleared returns if the "group_id" field was cleared in this mutation.
func (m *RedeemCodeMutation) GroupIDCleared() bool {
	_, ok := m.clearedFields[redeemcode.FieldGroupID]
	return ok
}

// ResetGroupID resets all changes to the "group_id" field.
func (m *RedeemCodeMutation) ResetGroupID() {
	m.group = nil
	delete(m.clearedFields, redeemcode.FieldGroupID)
}

// SetValidityDays sets the "validity_days" field.
func (m *RedeemCodeMutation) SetValidityDays(i int) {
	m.validity_days = &i
	m.addvalidity_days = nil
}

// ValidityDays returns the value of the "validity_days" field in the mutation.
func (m *RedeemCodeMutation) ValidityDays() (r int, exists bool) {
	v := m.validity_days
	if v == nil {
		return
	}
	return *v, true
}

// OldValidityDays returns the old "validity_days" field's value of the RedeemCode entity.
// If the RedeemCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RedeemCodeMutation) OldValidityDays(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValidityDays is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValidityDays requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValidityDays: %w", err)
	}
	return oldValue.ValidityDays, nil
}

// AddValidityDays adds i to the "validity_days" field.
func (m *RedeemCodeMutation) AddValidityDays(i int) {
	if m.addvalidity_days != nil {
		*m.addvalidity_days += i
	} else {
		m.addvalidity_days = &i
	}
}

// AddedValidityDays returns the value that was added to the "validity_days" field in this mutation.
func (m *RedeemCodeMutation) AddedValidityDays() (r int, exists bool) {
	v := m.addvalidity_days
	if v == nil {
		return
	}
	return *v, true
}

// ResetValidityDays resets all changes to the "validity_days" field.
func (m *RedeemCodeMutation) ResetValidityDays() {
	m.validity_days = nil
	m.addvalidity_days = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *RedeemCodeMutation) SetUserID(id int64) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *RedeemCodeMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[redeemcode.FieldUsedBy] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *RedeemCodeMutation) UserCleared() bool {
	return m.UsedByCleared() || m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *RedeemCodeMutation) UserID() (id int64, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *RedeemCodeMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *RedeemCodeMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearGroup clears the "group" edge to the Group entity.
func (m *RedeemCodeMutation) ClearGroup() {
	m.clearedgroup = true
	m.clearedFields[redeemcode.FieldGroupID] = struct{}{}
}

// GroupCleared reports if the "group" edge to the Group entity was cleared.
func (m *RedeemCodeMutation) GroupCleared() bool {
	return m.GroupIDCleared() || m.clearedgroup
}

// GroupIDs returns the "group" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GroupID instead. It exists only for internal usage by the builders.
func (m *RedeemCodeMutation) GroupIDs() (ids []int64) {
	if id := m.group; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGroup resets all changes to the "group" edge.
func (m *RedeemCodeMutation) ResetGroup() {
	m.group = nil
	m.clearedgroup = false
}

// Where appends a list predicates to the RedeemCodeMutation builder.
func (m *RedeemCodeMutation) Where(ps ...predicate.RedeemCode) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RedeemCodeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RedeemCodeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RedeemCode, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RedeemCodeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RedeemCodeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RedeemCode).
func (m *RedeemCodeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RedeemCodeMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.code != nil {
		fields = append(fields, redeemcode.FieldCode)
	}
	if m._type != nil {
		fields = append(fields, redeemcode.FieldType)
	}
	if m.value != nil {
		fields = append(fields, redeemcode.FieldValue)
	}
	if m.status != nil {
		fields = append(fields, redeemcode.FieldStatus)
	}
	if m.user != nil {
		fields = append(fields, redeemcode.FieldUsedBy)
	}
	if m.used_at != nil {
		fields = append(fields, redeemcode.FieldUsedAt)
	}
	if m.notes != nil {
		fields = append(fields, redeemcode.FieldNotes)
	}
	if m.created_at != nil {
		fields = append(fields, redeemcode.FieldCreatedAt)
	}
	if m.group != nil {
		fields = append(fields, redeemcode.FieldGroupID)
	}
	if m.validity_days != nil {
		fields = append(fields, redeemcode.FieldValidityDays)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RedeemCodeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case redeemcode.FieldCode:
		return m.Code()
	case redeemcode.FieldType:
		return m.GetType()
	case redeemcode.FieldValue:
		return m.Value()
	case redeemcode.FieldStatus:
		return m.Status()
	case redeemcode.FieldUsedBy:
		return m.UsedBy()
	case redeemcode.FieldUsedAt:
		return m.UsedAt()
	case redeemcode.FieldNotes:
		return m.Notes()
	case redeemcode.FieldCreatedAt:
		return m.CreatedAt()
	case redeemcode.FieldGroupID:
		return m.GroupID()
	case redeemcode.FieldValidityDays:
		return m.ValidityDays()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RedeemCodeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case redeemcode.FieldCode:
		return m.OldCode(ctx)
	case redeemcode.FieldType:
		return m.OldType(ctx)
	case redeemcode.FieldValue:
		return m.OldValue(ctx)
	case redeemcode.FieldStatus:
		return m.OldStatus(ctx)
	case redeemcode.FieldUsedBy:
		return m.OldUsedBy(ctx)
	case redeemcode.FieldUsedAt:
		return m.OldUsedAt(ctx)
	case redeemcode.FieldNotes:
		return m.OldNotes(ctx)
	case redeemcode.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case redeemcode.FieldGroupID:
		return m.OldGroupID(ctx)
	case redeemcode.FieldValidityDays:
		return m.OldValidityDays(ctx)
	}
	return nil, fmt.Errorf("unknown RedeemCode field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RedeemCodeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case redeemcode.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case redeemcode.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case redeemcode.FieldValue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case redeemcode.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case redeemcode.FieldUsedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsedBy(v)
		return nil
	case redeemcode.FieldUsedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsedAt(v)
		return nil
	case redeemcode.FieldNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotes(v)
		return nil
	case redeemcode.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case redeemcode.FieldGroupID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroupID(v)
		return nil
	case redeemcode.FieldValidityDays:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValidityDays(v)
		return nil
	}
	return fmt.Errorf("unknown RedeemCode field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RedeemCodeMutation) AddedFields() []string {
	var fields []string
	if m.addvalue != nil {
		fields = append(fields, redeemcode.FieldValue)
	}
	if m.addvalidity_days != nil {
		fields = append(fields, redeemcode.FieldValidityDays)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RedeemCodeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case redeemcode.FieldValue:
		return m.AddedValue()
	case redeemcode.FieldValidityDays:
		return m.AddedValidityDays()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RedeemCodeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case redeemcode.FieldValue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddValue(v)
		return nil
	case redeemcode.FieldValidityDays:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddValidityDays(v)
		return nil
	}
	return fmt.Errorf("unknown RedeemCode numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RedeemCodeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(redeemcode.FieldUsedBy) {
		fields = append(fields, redeemcode.FieldUsedBy)
	}
	if m.FieldCleared(redeemcode.FieldUsedAt) {
		fields = append(fields, redeemcode.FieldUsedAt)
	}
	if m.FieldCleared(redeemcode.FieldNotes) {
		fields = append(fields, redeemcode.FieldNotes)
	}
	if m.FieldCleared(redeemcode.FieldGroupID) {
		fields = append(fields, redeemcode.FieldGroupID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RedeemCodeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RedeemCodeMutation) ClearField(name string) error {
	switch name {
	case redeemcode.FieldUsedBy:
		m.ClearUsedBy()
		return nil
	case redeemcode.FieldUsedAt:
		m.ClearUsedAt()
		return nil
	case redeemcode.FieldNotes:
		m.ClearNotes()
		return nil
	case redeemcode.FieldGroupID:
		m.ClearGroupID()
		return nil
	}
	return fmt.Errorf("unknown RedeemCode nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RedeemCodeMutation) ResetField(name string) error {
	switch name {
	case redeemcode.FieldCode:
		m.ResetCode()
		return nil
	case redeemcode.FieldType:
		m.ResetType()
		return nil
	case redeemcode.FieldValue:
		m.ResetValue()
		return nil
	case redeemcode.FieldStatus:
		m.ResetStatus()
		return nil
	case redeemcode.FieldUsedBy:
		m.ResetUsedBy()
		return nil
	case redeemcode.FieldUsedAt:
		m.ResetUsedAt()
		return nil
	case redeemcode.FieldNotes:
		m.ResetNotes()
		return nil
	case redeemcode.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case redeemcode.FieldGroupID:
		m.ResetGroupID()
		return nil
	case redeemcode.FieldValidityDays:
		m.ResetValidityDays()
		return nil
	}
	return fmt.Errorf("unknown RedeemCode field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RedeemCodeMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, redeemcode.EdgeUser)
	}
	if m.group != nil {
		edges = append(edges, redeemcode.EdgeGroup)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RedeemCodeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case redeemcode.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case redeemcode.EdgeGroup:
		if id := m.group; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RedeemCodeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RedeemCodeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RedeemCodeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, redeemcode.EdgeUser)
	}
	if m.clearedgroup {
		edges = append(edges, redeemcode.EdgeGroup)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RedeemCodeMutation) EdgeCleared(name string) bool {
	switch name {
	case redeemcode.EdgeUser:
		return m.cleareduser
	case redeemcode.EdgeGroup:
		return m.clearedgroup
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RedeemCodeMutation) ClearEdge(name string) error {
	switch name {
	case redeemcode.EdgeUser:
		m.ClearUser()
		return nil
	case redeemcode.EdgeGroup:
		m.ClearGroup()
		return nil
	}
	return fmt.Errorf("unknown RedeemCode unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RedeemCodeMutation) ResetEdge(name string) error {
	switch name {
	case redeemcode.EdgeUser:
		m.ResetUser()
		return nil
	case redeemcode.EdgeGroup:
		m.ResetGroup()
		return nil
	}
	return fmt.Errorf("unknown RedeemCode edge %s", name)
}

// SettingMutation represents an operation that mutates the Setting nodes in the graph.
type SettingMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	key           *string
	value         *string
	updated_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Setting, error)
	predicates    []predicate.Setting
}

var _ ent.Mutation = (*SettingMutation)(nil)

// settingOption allows management of the mutation configuration using functional options.
type settingOption func(*SettingMutation)

// newSettingMutation creates new mutation for the Setting entity.
func newSettingMutation(c config, op Op, opts ...settingOption) *SettingMutation {
	m := &SettingMutation{
		config:        c,
		op:            op,
		typ:           TypeSetting,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSettingID sets the ID field of the mutation.
func withSettingID(id int64) settingOption {
	return func(m *SettingMutation) {
		var (
			err   error
			once  sync.Once
			value *Setting
		)
		m.oldValue = func(ctx context.Context) (*Setting, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Setting.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSetting sets the old Setting of the mutation.
func withSetting(node *Setting) settingOption {
	return func(m *SettingMutation) {
		m.oldValue = func(context.Context) (*Setting, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SettingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SettingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SettingMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SettingMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Setting.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetKey sets the "key" field.
func (m *SettingMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *SettingMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *SettingMutation) ResetKey() {
	m.key = nil
}

// SetValue sets the "value" field.
func (m *SettingMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *SettingMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *SettingMutation) ResetValue() {
	m.value = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SettingMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SettingMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SettingMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the SettingMutation builder.
func (m *SettingMutation) Where(ps ...predicate.Setting) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SettingMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SettingMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Setting, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SettingMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SettingMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Setting).
func (m *SettingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SettingMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.key != nil {
		fields = append(fields, setting.FieldKey)
	}
	if m.value != nil {
		fields = append(fields, setting.FieldValue)
	}
	if m.updated_at != nil {
		fields = append(fields, setting.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SettingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case setting.FieldKey:
		return m.Key()
	case setting.FieldValue:
		return m.Value()
	case setting.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SettingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case setting.FieldKey:
		return m.OldKey(ctx)
	case setting.FieldValue:
		return m.OldValue(ctx)
	case setting.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Setting field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SettingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case setting.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case setting.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case setting.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Setting field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SettingMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SettingMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SettingMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Setting numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SettingMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SettingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SettingMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Setting nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SettingMutation) ResetField(name string) error {
	switch name {
	case setting.FieldKey:
		m.ResetKey()
		return nil
	case setting.FieldValue:
		m.ResetValue()
		return nil
	case setting.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Setting field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SettingMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SettingMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SettingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SettingMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SettingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SettingMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SettingMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Setting unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SettingMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Setting edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                            Op
	typ                           string
	id                            *int64
	created_at                    *time.Time
	updated_at                    *time.Time
	deleted_at                    *time.Time
	email                         *string
	password_hash                 *string
	role                          *string
	balance                       *float64
	addbalance                    *float64
	concurrency                   *int
	addconcurrency                *int
	status                        *string
	username                      *string
	wechat                        *string
	notes                         *string
	clearedFields                 map[string]struct{}
	api_keys                      map[int64]struct{}
	removedapi_keys               map[int64]struct{}
	clearedapi_keys               bool
	redeem_codes                  map[int64]struct{}
	removedredeem_codes           map[int64]struct{}
	clearedredeem_codes           bool
	subscriptions                 map[int64]struct{}
	removedsubscriptions          map[int64]struct{}
	clearedsubscriptions          bool
	assigned_subscriptions        map[int64]struct{}
	removedassigned_subscriptions map[int64]struct{}
	clearedassigned_subscriptions bool
	allowed_groups                map[int64]struct{}
	removedallowed_groups         map[int64]struct{}
	clearedallowed_groups         bool
	done                          bool
	oldValue                      func(context.Context) (*User, error)
	predicates                    []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int64) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UserMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UserMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *UserMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[user.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *UserMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UserMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, user.FieldDeletedAt)
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetPasswordHash sets the "password_hash" field.
func (m *UserMutation) SetPasswordHash(s string) {
	m.password_hash = &s
}

// PasswordHash returns the value of the "password_hash" field in the mutation.
func (m *UserMutation) PasswordHash() (r string, exists bool) {
	v := m.password_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordHash returns the old "password_hash" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPasswordHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordHash: %w", err)
	}
	return oldValue.PasswordHash, nil
}

// ResetPasswordHash resets all changes to the "password_hash" field.
func (m *UserMutation) ResetPasswordHash() {
	m.password_hash = nil
}

// SetRole sets the "role" field.
func (m *UserMutation) SetRole(s string) {
	m.role = &s
}

// Role returns the value of the "role" field in the mutation.
func (m *UserMutation) Role() (r string, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldRole(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *UserMutation) ResetRole() {
	m.role = nil
}

// SetBalance sets the "balance" field.
func (m *UserMutation) SetBalance(f float64) {
	m.balance = &f
	m.addbalance = nil
}

// Balance returns the value of the "balance" field in the mutation.
func (m *UserMutation) Balance() (r float64, exists bool) {
	v := m.balance
	if v == nil {
		return
	}
	return *v, true
}

// OldBalance returns the old "balance" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldBalance(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBalance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBalance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBalance: %w", err)
	}
	return oldValue.Balance, nil
}

// AddBalance adds f to the "balance" field.
func (m *UserMutation) AddBalance(f float64) {
	if m.addbalance != nil {
		*m.addbalance += f
	} else {
		m.addbalance = &f
	}
}

// AddedBalance returns the value that was added to the "balance" field in this mutation.
func (m *UserMutation) AddedBalance() (r float64, exists bool) {
	v := m.addbalance
	if v == nil {
		return
	}
	return *v, true
}

// ResetBalance resets all changes to the "balance" field.
func (m *UserMutation) ResetBalance() {
	m.balance = nil
	m.addbalance = nil
}

// SetConcurrency sets the "concurrency" field.
func (m *UserMutation) SetConcurrency(i int) {
	m.concurrency = &i
	m.addconcurrency = nil
}

// Concurrency returns the value of the "concurrency" field in the mutation.
func (m *UserMutation) Concurrency() (r int, exists bool) {
	v := m.concurrency
	if v == nil {
		return
	}
	return *v, true
}

// OldConcurrency returns the old "concurrency" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldConcurrency(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConcurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConcurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConcurrency: %w", err)
	}
	return oldValue.Concurrency, nil
}

// AddConcurrency adds i to the "concurrency" field.
func (m *UserMutation) AddConcurrency(i int) {
	if m.addconcurrency != nil {
		*m.addconcurrency += i
	} else {
		m.addconcurrency = &i
	}
}

// AddedConcurrency returns the value that was added to the "concurrency" field in this mutation.
func (m *UserMutation) AddedConcurrency() (r int, exists bool) {
	v := m.addconcurrency
	if v == nil {
		return
	}
	return *v, true
}

// ResetConcurrency resets all changes to the "concurrency" field.
func (m *UserMutation) ResetConcurrency() {
	m.concurrency = nil
	m.addconcurrency = nil
}

// SetStatus sets the "status" field.
func (m *UserMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *UserMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *UserMutation) ResetStatus() {
	m.status = nil
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
}

// SetWechat sets the "wechat" field.
func (m *UserMutation) SetWechat(s string) {
	m.wechat = &s
}

// Wechat returns the value of the "wechat" field in the mutation.
func (m *UserMutation) Wechat() (r string, exists bool) {
	v := m.wechat
	if v == nil {
		return
	}
	return *v, true
}

// OldWechat returns the old "wechat" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldWechat(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWechat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWechat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWechat: %w", err)
	}
	return oldValue.Wechat, nil
}

// ResetWechat resets all changes to the "wechat" field.
func (m *UserMutation) ResetWechat() {
	m.wechat = nil
}

// SetNotes sets the "notes" field.
func (m *UserMutation) SetNotes(s string) {
	m.notes = &s
}

// Notes returns the value of the "notes" field in the mutation.
func (m *UserMutation) Notes() (r string, exists bool) {
	v := m.notes
	if v == nil {
		return
	}
	return *v, true
}

// OldNotes returns the old "notes" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldNotes(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotes: %w", err)
	}
	return oldValue.Notes, nil
}

// ResetNotes resets all changes to the "notes" field.
func (m *UserMutation) ResetNotes() {
	m.notes = nil
}

// AddAPIKeyIDs adds the "api_keys" edge to the ApiKey entity by ids.
func (m *UserMutation) AddAPIKeyIDs(ids ...int64) {
	if m.api_keys == nil {
		m.api_keys = make(map[int64]struct{})
	}
	for i := range ids {
		m.api_keys[ids[i]] = struct{}{}
	}
}

// ClearAPIKeys clears the "api_keys" edge to the ApiKey entity.
func (m *UserMutation) ClearAPIKeys() {
	m.clearedapi_keys = true
}

// APIKeysCleared reports if the "api_keys" edge to the ApiKey entity was cleared.
func (m *UserMutation) APIKeysCleared() bool {
	return m.clearedapi_keys
}

// RemoveAPIKeyIDs removes the "api_keys" edge to the ApiKey entity by IDs.
func (m *UserMutation) RemoveAPIKeyIDs(ids ...int64) {
	if m.removedapi_keys == nil {
		m.removedapi_keys = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.api_keys, ids[i])
		m.removedapi_keys[ids[i]] = struct{}{}
	}
}

// RemovedAPIKeys returns the removed IDs of the "api_keys" edge to the ApiKey entity.
func (m *UserMutation) RemovedAPIKeysIDs() (ids []int64) {
	for id := range m.removedapi_keys {
		ids = append(ids, id)
	}
	return
}

// APIKeysIDs returns the "api_keys" edge IDs in the mutation.
func (m *UserMutation) APIKeysIDs() (ids []int64) {
	for id := range m.api_keys {
		ids = append(ids, id)
	}
	return
}

// ResetAPIKeys resets all changes to the "api_keys" edge.
func (m *UserMutation) ResetAPIKeys() {
	m.api_keys = nil
	m.clearedapi_keys = false
	m.removedapi_keys = nil
}

// AddRedeemCodeIDs adds the "redeem_codes" edge to the RedeemCode entity by ids.
func (m *UserMutation) AddRedeemCodeIDs(ids ...int64) {
	if m.redeem_codes == nil {
		m.redeem_codes = make(map[int64]struct{})
	}
	for i := range ids {
		m.redeem_codes[ids[i]] = struct{}{}
	}
}

// ClearRedeemCodes clears the "redeem_codes" edge to the RedeemCode entity.
func (m *UserMutation) ClearRedeemCodes() {
	m.clearedredeem_codes = true
}

// RedeemCodesCleared reports if the "redeem_codes" edge to the RedeemCode entity was cleared.
func (m *UserMutation) RedeemCodesCleared() bool {
	return m.clearedredeem_codes
}

// RemoveRedeemCodeIDs removes the "redeem_codes" edge to the RedeemCode entity by IDs.
func (m *UserMutation) RemoveRedeemCodeIDs(ids ...int64) {
	if m.removedredeem_codes == nil {
		m.removedredeem_codes = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.redeem_codes, ids[i])
		m.removedredeem_codes[ids[i]] = struct{}{}
	}
}

// RemovedRedeemCodes returns the removed IDs of the "redeem_codes" edge to the RedeemCode entity.
func (m *UserMutation) RemovedRedeemCodesIDs() (ids []int64) {
	for id := range m.removedredeem_codes {
		ids = append(ids, id)
	}
	return
}

// RedeemCodesIDs returns the "redeem_codes" edge IDs in the mutation.
func (m *UserMutation) RedeemCodesIDs() (ids []int64) {
	for id := range m.redeem_codes {
		ids = append(ids, id)
	}
	return
}

// ResetRedeemCodes resets all changes to the "redeem_codes" edge.
func (m *UserMutation) ResetRedeemCodes() {
	m.redeem_codes = nil
	m.clearedredeem_codes = false
	m.removedredeem_codes = nil
}

// AddSubscriptionIDs adds the "subscriptions" edge to the UserSubscription entity by ids.
func (m *UserMutation) AddSubscriptionIDs(ids ...int64) {
	if m.subscriptions == nil {
		m.subscriptions = make(map[int64]struct{})
	}
	for i := range ids {
		m.subscriptions[ids[i]] = struct{}{}
	}
}

// ClearSubscriptions clears the "subscriptions" edge to the UserSubscription entity.
func (m *UserMutation) ClearSubscriptions() {
	m.clearedsubscriptions = true
}

// SubscriptionsCleared reports if the "subscriptions" edge to the UserSubscription entity was cleared.
func (m *UserMutation) SubscriptionsCleared() bool {
	return m.clearedsubscriptions
}

// RemoveSubscriptionIDs removes the "subscriptions" edge to the UserSubscription entity by IDs.
func (m *UserMutation) RemoveSubscriptionIDs(ids ...int64) {
	if m.removedsubscriptions == nil {
		m.removedsubscriptions = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.subscriptions, ids[i])
		m.removedsubscriptions[ids[i]] = struct{}{}
	}
}

// RemovedSubscriptions returns the removed IDs of the "subscriptions" edge to the UserSubscription entity.
func (m *UserMutation) RemovedSubscriptionsIDs() (ids []int64) {
	for id := range m.removedsubscriptions {
		ids = append(ids, id)
	}
	return
}

// SubscriptionsIDs returns the "subscriptions" edge IDs in the mutation.
func (m *UserMutation) SubscriptionsIDs() (ids []int64) {
	for id := range m.subscriptions {
		ids = append(ids, id)
	}
	return
}

// ResetSubscriptions resets all changes to the "subscriptions" edge.
func (m *UserMutation) ResetSubscriptions() {
	m.subscriptions = nil
	m.clearedsubscriptions = false
	m.removedsubscriptions = nil
}

// AddAssignedSubscriptionIDs adds the "assigned_subscriptions" edge to the UserSubscription entity by ids.
func (m *UserMutation) AddAssignedSubscriptionIDs(ids ...int64) {
	if m.assigned_subscriptions == nil {
		m.assigned_subscriptions = make(map[int64]struct{})
	}
	for i := range ids {
		m.assigned_subscriptions[ids[i]] = struct{}{}
	}
}

// ClearAssignedSubscriptions clears the "assigned_subscriptions" edge to the UserSubscription entity.
func (m *UserMutation) ClearAssignedSubscriptions() {
	m.clearedassigned_subscriptions = true
}

// AssignedSubscriptionsCleared reports if the "assigned_subscriptions" edge to the UserSubscription entity was cleared.
func (m *UserMutation) AssignedSubscriptionsCleared() bool {
	return m.clearedassigned_subscriptions
}

// RemoveAssignedSubscriptionIDs removes the "assigned_subscriptions" edge to the UserSubscription entity by IDs.
func (m *UserMutation) RemoveAssignedSubscriptionIDs(ids ...int64) {
	if m.removedassigned_subscriptions == nil {
		m.removedassigned_subscriptions = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.assigned_subscriptions, ids[i])
		m.removedassigned_subscriptions[ids[i]] = struct{}{}
	}
}

// RemovedAssignedSubscriptions returns the removed IDs of the "assigned_subscriptions" edge to the UserSubscription entity.
func (m *UserMutation) RemovedAssignedSubscriptionsIDs() (ids []int64) {
	for id := range m.removedassigned_subscriptions {
		ids = append(ids, id)
	}
	return
}

// AssignedSubscriptionsIDs returns the "assigned_subscriptions" edge IDs in the mutation.
func (m *UserMutation) AssignedSubscriptionsIDs() (ids []int64) {
	for id := range m.assigned_subscriptions {
		ids = append(ids, id)
	}
	return
}

// ResetAssignedSubscriptions resets all changes to the "assigned_subscriptions" edge.
func (m *UserMutation) ResetAssignedSubscriptions() {
	m.assigned_subscriptions = nil
	m.clearedassigned_subscriptions = false
	m.removedassigned_subscriptions = nil
}

// AddAllowedGroupIDs adds the "allowed_groups" edge to the Group entity by ids.
func (m *UserMutation) AddAllowedGroupIDs(ids ...int64) {
	if m.allowed_groups == nil {
		m.allowed_groups = make(map[int64]struct{})
	}
	for i := range ids {
		m.allowed_groups[ids[i]] = struct{}{}
	}
}

// ClearAllowedGroups clears the "allowed_groups" edge to the Group entity.
func (m *UserMutation) ClearAllowedGroups() {
	m.clearedallowed_groups = true
}

// AllowedGroupsCleared reports if the "allowed_groups" edge to the Group entity was cleared.
func (m *UserMutation) AllowedGroupsCleared() bool {
	return m.clearedallowed_groups
}

// RemoveAllowedGroupIDs removes the "allowed_groups" edge to the Group entity by IDs.
func (m *UserMutation) RemoveAllowedGroupIDs(ids ...int64) {
	if m.removedallowed_groups == nil {
		m.removedallowed_groups = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.allowed_groups, ids[i])
		m.removedallowed_groups[ids[i]] = struct{}{}
	}
}

// RemovedAllowedGroups returns the removed IDs of the "allowed_groups" edge to the Group entity.
func (m *UserMutation) RemovedAllowedGroupsIDs() (ids []int64) {
	for id := range m.removedallowed_groups {
		ids = append(ids, id)
	}
	return
}

// AllowedGroupsIDs returns the "allowed_groups" edge IDs in the mutation.
func (m *UserMutation) AllowedGroupsIDs() (ids []int64) {
	for id := range m.allowed_groups {
		ids = append(ids, id)
	}
	return
}

// ResetAllowedGroups resets all changes to the "allowed_groups" edge.
func (m *UserMutation) ResetAllowedGroups() {
	m.allowed_groups = nil
	m.clearedallowed_groups = false
	m.removedallowed_groups = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, user.FieldDeletedAt)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.password_hash != nil {
		fields = append(fields, user.FieldPasswordHash)
	}
	if m.role != nil {
		fields = append(fields, user.FieldRole)
	}
	if m.balance != nil {
		fields = append(fields, user.FieldBalance)
	}
	if m.concurrency != nil {
		fields = append(fields, user.FieldConcurrency)
	}
	if m.status != nil {
		fields = append(fields, user.FieldStatus)
	}
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.wechat != nil {
		fields = append(fields, user.FieldWechat)
	}
	if m.notes != nil {
		fields = append(fields, user.FieldNotes)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldDeletedAt:
		return m.DeletedAt()
	case user.FieldEmail:
		return m.Email()
	case user.FieldPasswordHash:
		return m.PasswordHash()
	case user.FieldRole:
		return m.Role()
	case user.FieldBalance:
		return m.Balance()
	case user.FieldConcurrency:
		return m.Concurrency()
	case user.FieldStatus:
		return m.Status()
	case user.FieldUsername:
		return m.Username()
	case user.FieldWechat:
		return m.Wechat()
	case user.FieldNotes:
		return m.Notes()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldPasswordHash:
		return m.OldPasswordHash(ctx)
	case user.FieldRole:
		return m.OldRole(ctx)
	case user.FieldBalance:
		return m.OldBalance(ctx)
	case user.FieldConcurrency:
		return m.OldConcurrency(ctx)
	case user.FieldStatus:
		return m.OldStatus(ctx)
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldWechat:
		return m.OldWechat(ctx)
	case user.FieldNotes:
		return m.OldNotes(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldPasswordHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordHash(v)
		return nil
	case user.FieldRole:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case user.FieldBalance:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBalance(v)
		return nil
	case user.FieldConcurrency:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConcurrency(v)
		return nil
	case user.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldWechat:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWechat(v)
		return nil
	case user.FieldNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotes(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.addbalance != nil {
		fields = append(fields, user.FieldBalance)
	}
	if m.addconcurrency != nil {
		fields = append(fields, user.FieldConcurrency)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldBalance:
		return m.AddedBalance()
	case user.FieldConcurrency:
		return m.AddedConcurrency()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldBalance:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBalance(v)
		return nil
	case user.FieldConcurrency:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddConcurrency(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldDeletedAt) {
		fields = append(fields, user.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldPasswordHash:
		m.ResetPasswordHash()
		return nil
	case user.FieldRole:
		m.ResetRole()
		return nil
	case user.FieldBalance:
		m.ResetBalance()
		return nil
	case user.FieldConcurrency:
		m.ResetConcurrency()
		return nil
	case user.FieldStatus:
		m.ResetStatus()
		return nil
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldWechat:
		m.ResetWechat()
		return nil
	case user.FieldNotes:
		m.ResetNotes()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.api_keys != nil {
		edges = append(edges, user.EdgeAPIKeys)
	}
	if m.redeem_codes != nil {
		edges = append(edges, user.EdgeRedeemCodes)
	}
	if m.subscriptions != nil {
		edges = append(edges, user.EdgeSubscriptions)
	}
	if m.assigned_subscriptions != nil {
		edges = append(edges, user.EdgeAssignedSubscriptions)
	}
	if m.allowed_groups != nil {
		edges = append(edges, user.EdgeAllowedGroups)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeAPIKeys:
		ids := make([]ent.Value, 0, len(m.api_keys))
		for id := range m.api_keys {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeRedeemCodes:
		ids := make([]ent.Value, 0, len(m.redeem_codes))
		for id := range m.redeem_codes {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSubscriptions:
		ids := make([]ent.Value, 0, len(m.subscriptions))
		for id := range m.subscriptions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAssignedSubscriptions:
		ids := make([]ent.Value, 0, len(m.assigned_subscriptions))
		for id := range m.assigned_subscriptions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAllowedGroups:
		ids := make([]ent.Value, 0, len(m.allowed_groups))
		for id := range m.allowed_groups {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedapi_keys != nil {
		edges = append(edges, user.EdgeAPIKeys)
	}
	if m.removedredeem_codes != nil {
		edges = append(edges, user.EdgeRedeemCodes)
	}
	if m.removedsubscriptions != nil {
		edges = append(edges, user.EdgeSubscriptions)
	}
	if m.removedassigned_subscriptions != nil {
		edges = append(edges, user.EdgeAssignedSubscriptions)
	}
	if m.removedallowed_groups != nil {
		edges = append(edges, user.EdgeAllowedGroups)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeAPIKeys:
		ids := make([]ent.Value, 0, len(m.removedapi_keys))
		for id := range m.removedapi_keys {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeRedeemCodes:
		ids := make([]ent.Value, 0, len(m.removedredeem_codes))
		for id := range m.removedredeem_codes {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSubscriptions:
		ids := make([]ent.Value, 0, len(m.removedsubscriptions))
		for id := range m.removedsubscriptions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAssignedSubscriptions:
		ids := make([]ent.Value, 0, len(m.removedassigned_subscriptions))
		for id := range m.removedassigned_subscriptions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAllowedGroups:
		ids := make([]ent.Value, 0, len(m.removedallowed_groups))
		for id := range m.removedallowed_groups {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedapi_keys {
		edges = append(edges, user.EdgeAPIKeys)
	}
	if m.clearedredeem_codes {
		edges = append(edges, user.EdgeRedeemCodes)
	}
	if m.clearedsubscriptions {
		edges = append(edges, user.EdgeSubscriptions)
	}
	if m.clearedassigned_subscriptions {
		edges = append(edges, user.EdgeAssignedSubscriptions)
	}
	if m.clearedallowed_groups {
		edges = append(edges, user.EdgeAllowedGroups)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeAPIKeys:
		return m.clearedapi_keys
	case user.EdgeRedeemCodes:
		return m.clearedredeem_codes
	case user.EdgeSubscriptions:
		return m.clearedsubscriptions
	case user.EdgeAssignedSubscriptions:
		return m.clearedassigned_subscriptions
	case user.EdgeAllowedGroups:
		return m.clearedallowed_groups
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeAPIKeys:
		m.ResetAPIKeys()
		return nil
	case user.EdgeRedeemCodes:
		m.ResetRedeemCodes()
		return nil
	case user.EdgeSubscriptions:
		m.ResetSubscriptions()
		return nil
	case user.EdgeAssignedSubscriptions:
		m.ResetAssignedSubscriptions()
		return nil
	case user.EdgeAllowedGroups:
		m.ResetAllowedGroups()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// UserAllowedGroupMutation represents an operation that mutates the UserAllowedGroup nodes in the graph.
type UserAllowedGroupMutation struct {
	config
	op            Op
	typ           string
	created_at    *time.Time
	clearedFields map[string]struct{}
	user          *int64
	cleareduser   bool
	group         *int64
	clearedgroup  bool
	done          bool
	oldValue      func(context.Context) (*UserAllowedGroup, error)
	predicates    []predicate.UserAllowedGroup
}

var _ ent.Mutation = (*UserAllowedGroupMutation)(nil)

// userallowedgroupOption allows management of the mutation configuration using functional options.
type userallowedgroupOption func(*UserAllowedGroupMutation)

// newUserAllowedGroupMutation creates new mutation for the UserAllowedGroup entity.
func newUserAllowedGroupMutation(c config, op Op, opts ...userallowedgroupOption) *UserAllowedGroupMutation {
	m := &UserAllowedGroupMutation{
		config:        c,
		op:            op,
		typ:           TypeUserAllowedGroup,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserAllowedGroupMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserAllowedGroupMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetUserID sets the "user_id" field.
func (m *UserAllowedGroupMutation) SetUserID(i int64) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserAllowedGroupMutation) UserID() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserAllowedGroupMutation) ResetUserID() {
	m.user = nil
}

// SetGroupID sets the "group_id" field.
func (m *UserAllowedGroupMutation) SetGroupID(i int64) {
	m.group = &i
}

// GroupID returns the value of the "group_id" field in the mutation.
func (m *UserAllowedGroupMutation) GroupID() (r int64, exists bool) {
	v := m.group
	if v == nil {
		return
	}
	return *v, true
}

// ResetGroupID resets all changes to the "group_id" field.
func (m *UserAllowedGroupMutation) ResetGroupID() {
	m.group = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserAllowedGroupMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserAllowedGroupMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserAllowedGroupMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserAllowedGroupMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[userallowedgroup.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserAllowedGroupMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserAllowedGroupMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserAllowedGroupMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearGroup clears the "group" edge to the Group entity.
func (m *UserAllowedGroupMutation) ClearGroup() {
	m.clearedgroup = true
	m.clearedFields[userallowedgroup.FieldGroupID] = struct{}{}
}

// GroupCleared reports if the "group" edge to the Group entity was cleared.
func (m *UserAllowedGroupMutation) GroupCleared() bool {
	return m.clearedgroup
}

// GroupIDs returns the "group" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GroupID instead. It exists only for internal usage by the builders.
func (m *UserAllowedGroupMutation) GroupIDs() (ids []int64) {
	if id := m.group; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGroup resets all changes to the "group" edge.
func (m *UserAllowedGroupMutation) ResetGroup() {
	m.group = nil
	m.clearedgroup = false
}

// Where appends a list predicates to the UserAllowedGroupMutation builder.
func (m *UserAllowedGroupMutation) Where(ps ...predicate.UserAllowedGroup) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserAllowedGroupMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserAllowedGroupMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserAllowedGroup, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserAllowedGroupMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserAllowedGroupMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserAllowedGroup).
func (m *UserAllowedGroupMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserAllowedGroupMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.user != nil {
		fields = append(fields, userallowedgroup.FieldUserID)
	}
	if m.group != nil {
		fields = append(fields, userallowedgroup.FieldGroupID)
	}
	if m.created_at != nil {
		fields = append(fields, userallowedgroup.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserAllowedGroupMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userallowedgroup.FieldUserID:
		return m.UserID()
	case userallowedgroup.FieldGroupID:
		return m.GroupID()
	case userallowedgroup.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserAllowedGroupMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, errors.New("edge schema UserAllowedGroup does not support getting old values")
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserAllowedGroupMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userallowedgroup.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case userallowedgroup.FieldGroupID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroupID(v)
		return nil
	case userallowedgroup.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown UserAllowedGroup field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserAllowedGroupMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserAllowedGroupMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserAllowedGroupMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserAllowedGroup numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserAllowedGroupMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserAllowedGroupMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserAllowedGroupMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserAllowedGroup nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserAllowedGroupMutation) ResetField(name string) error {
	switch name {
	case userallowedgroup.FieldUserID:
		m.ResetUserID()
		return nil
	case userallowedgroup.FieldGroupID:
		m.ResetGroupID()
		return nil
	case userallowedgroup.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown UserAllowedGroup field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserAllowedGroupMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, userallowedgroup.EdgeUser)
	}
	if m.group != nil {
		edges = append(edges, userallowedgroup.EdgeGroup)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserAllowedGroupMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userallowedgroup.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case userallowedgroup.EdgeGroup:
		if id := m.group; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserAllowedGroupMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserAllowedGroupMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserAllowedGroupMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, userallowedgroup.EdgeUser)
	}
	if m.clearedgroup {
		edges = append(edges, userallowedgroup.EdgeGroup)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserAllowedGroupMutation) EdgeCleared(name string) bool {
	switch name {
	case userallowedgroup.EdgeUser:
		return m.cleareduser
	case userallowedgroup.EdgeGroup:
		return m.clearedgroup
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserAllowedGroupMutation) ClearEdge(name string) error {
	switch name {
	case userallowedgroup.EdgeUser:
		m.ClearUser()
		return nil
	case userallowedgroup.EdgeGroup:
		m.ClearGroup()
		return nil
	}
	return fmt.Errorf("unknown UserAllowedGroup unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserAllowedGroupMutation) ResetEdge(name string) error {
	switch name {
	case userallowedgroup.EdgeUser:
		m.ResetUser()
		return nil
	case userallowedgroup.EdgeGroup:
		m.ResetGroup()
		return nil
	}
	return fmt.Errorf("unknown UserAllowedGroup edge %s", name)
}

// UserSubscriptionMutation represents an operation that mutates the UserSubscription nodes in the graph.
type UserSubscriptionMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int64
	created_at              *time.Time
	updated_at              *time.Time
	starts_at               *time.Time
	expires_at              *time.Time
	status                  *string
	daily_window_start      *time.Time
	weekly_window_start     *time.Time
	monthly_window_start    *time.Time
	daily_usage_usd         *float64
	adddaily_usage_usd      *float64
	weekly_usage_usd        *float64
	addweekly_usage_usd     *float64
	monthly_usage_usd       *float64
	addmonthly_usage_usd    *float64
	assigned_at             *time.Time
	notes                   *string
	clearedFields           map[string]struct{}
	user                    *int64
	cleareduser             bool
	group                   *int64
	clearedgroup            bool
	assigned_by_user        *int64
	clearedassigned_by_user bool
	done                    bool
	oldValue                func(context.Context) (*UserSubscription, error)
	predicates              []predicate.UserSubscription
}

var _ ent.Mutation = (*UserSubscriptionMutation)(nil)

// usersubscriptionOption allows management of the mutation configuration using functional options.
type usersubscriptionOption func(*UserSubscriptionMutation)

// newUserSubscriptionMutation creates new mutation for the UserSubscription entity.
func newUserSubscriptionMutation(c config, op Op, opts ...usersubscriptionOption) *UserSubscriptionMutation {
	m := &UserSubscriptionMutation{
		config:        c,
		op:            op,
		typ:           TypeUserSubscription,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserSubscriptionID sets the ID field of the mutation.
func withUserSubscriptionID(id int64) usersubscriptionOption {
	return func(m *UserSubscriptionMutation) {
		var (
			err   error
			once  sync.Once
			value *UserSubscription
		)
		m.oldValue = func(ctx context.Context) (*UserSubscription, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserSubscription.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserSubscription sets the old UserSubscription of the mutation.
func withUserSubscription(node *UserSubscription) usersubscriptionOption {
	return func(m *UserSubscriptionMutation) {
		m.oldValue = func(context.Context) (*UserSubscription, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserSubscriptionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserSubscriptionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserSubscriptionMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserSubscriptionMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserSubscription.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserSubscriptionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserSubscriptionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserSubscription entity.
// If the UserSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSubscriptionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserSubscriptionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserSubscriptionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserSubscriptionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserSubscription entity.
// If the UserSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSubscriptionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserSubscriptionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUserID sets the "user_id" field.
func (m *UserSubscriptionMutation) SetUserID(i int64) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserSubscriptionMutation) UserID() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserSubscription entity.
// If the UserSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSubscriptionMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserSubscriptionMutation) ResetUserID() {
	m.user = nil
}

// SetGroupID sets the "group_id" field.
func (m *UserSubscriptionMutation) SetGroupID(i int64) {
	m.group = &i
}

// GroupID returns the value of the "group_id" field in the mutation.
func (m *UserSubscriptionMutation) GroupID() (r int64, exists bool) {
	v := m.group
	if v == nil {
		return
	}
	return *v, true
}

// OldGroupID returns the old "group_id" field's value of the UserSubscription entity.
// If the UserSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSubscriptionMutation) OldGroupID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGroupID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGroupID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGroupID: %w", err)
	}
	return oldValue.GroupID, nil
}

// ResetGroupID resets all changes to the "group_id" field.
func (m *UserSubscriptionMutation) ResetGroupID() {
	m.group = nil
}

// SetStartsAt sets the "starts_at" field.
func (m *UserSubscriptionMutation) SetStartsAt(t time.Time) {
	m.starts_at = &t
}

// StartsAt returns the value of the "starts_at" field in the mutation.
func (m *UserSubscriptionMutation) StartsAt() (r time.Time, exists bool) {
	v := m.starts_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartsAt returns the old "starts_at" field's value of the UserSubscription entity.
// If the UserSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSubscriptionMutation) OldStartsAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartsAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartsAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartsAt: %w", err)
	}
	return oldValue.StartsAt, nil
}

// ResetStartsAt resets all changes to the "starts_at" field.
func (m *UserSubscriptionMutation) ResetStartsAt() {
	m.starts_at = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *UserSubscriptionMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *UserSubscriptionMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the UserSubscription entity.
// If the UserSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSubscriptionMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *UserSubscriptionMutation) ResetExpiresAt() {
	m.expires_at = nil
}

// SetStatus sets the "status" field.
func (m *UserSubscriptionMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *UserSubscriptionMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the UserSubscription entity.
// If the UserSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSubscriptionMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *UserSubscriptionMutation) ResetStatus() {
	m.status = nil
}

// SetDailyWindowStart sets the "daily_window_start" field.
func (m *UserSubscriptionMutation) SetDailyWindowStart(t time.Time) {
	m.daily_window_start = &t
}

// DailyWindowStart returns the value of the "daily_window_start" field in the mutation.
func (m *UserSubscriptionMutation) DailyWindowStart() (r time.Time, exists bool) {
	v := m.daily_window_start
	if v == nil {
		return
	}
	return *v, true
}

// OldDailyWindowStart returns the old "daily_window_start" field's value of the UserSubscription entity.
// If the UserSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSubscriptionMutation) OldDailyWindowStart(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDailyWindowStart is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDailyWindowStart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDailyWindowStart: %w", err)
	}
	return oldValue.DailyWindowStart, nil
}

// ClearDailyWindowStart clears the value of the "daily_window_start" field.
func (m *UserSubscriptionMutation) ClearDailyWindowStart() {
	m.daily_window_start = nil
	m.clearedFields[usersubscription.FieldDailyWindowStart] = struct{}{}
}

// DailyWindowStartCleared returns if the "daily_window_start" field was cleared in this mutation.
func (m *UserSubscriptionMutation) DailyWindowStartCleared() bool {
	_, ok := m.clearedFields[usersubscription.FieldDailyWindowStart]
	return ok
}

// ResetDailyWindowStart resets all changes to the "daily_window_start" field.
func (m *UserSubscriptionMutation) ResetDailyWindowStart() {
	m.daily_window_start = nil
	delete(m.clearedFields, usersubscription.FieldDailyWindowStart)
}

// SetWeeklyWindowStart sets the "weekly_window_start" field.
func (m *UserSubscriptionMutation) SetWeeklyWindowStart(t time.Time) {
	m.weekly_window_start = &t
}

// WeeklyWindowStart returns the value of the "weekly_window_start" field in the mutation.
func (m *UserSubscriptionMutation) WeeklyWindowStart() (r time.Time, exists bool) {
	v := m.weekly_window_start
	if v == nil {
		return
	}
	return *v, true
}

// OldWeeklyWindowStart returns the old "weekly_window_start" field's value of the UserSubscription entity.
// If the UserSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSubscriptionMutation) OldWeeklyWindowStart(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWeeklyWindowStart is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWeeklyWindowStart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWeeklyWindowStart: %w", err)
	}
	return oldValue.WeeklyWindowStart, nil
}

// ClearWeeklyWindowStart clears the value of the "weekly_window_start" field.
func (m *UserSubscriptionMutation) ClearWeeklyWindowStart() {
	m.weekly_window_start = nil
	m.clearedFields[usersubscription.FieldWeeklyWindowStart] = struct{}{}
}

// WeeklyWindowStartCleared returns if the "weekly_window_start" field was cleared in this mutation.
func (m *UserSubscriptionMutation) WeeklyWindowStartCleared() bool {
	_, ok := m.clearedFields[usersubscription.FieldWeeklyWindowStart]
	return ok
}

// ResetWeeklyWindowStart resets all changes to the "weekly_window_start" field.
func (m *UserSubscriptionMutation) ResetWeeklyWindowStart() {
	m.weekly_window_start = nil
	delete(m.clearedFields, usersubscription.FieldWeeklyWindowStart)
}

// SetMonthlyWindowStart sets the "monthly_window_start" field.
func (m *UserSubscriptionMutation) SetMonthlyWindowStart(t time.Time) {
	m.monthly_window_start = &t
}

// MonthlyWindowStart returns the value of the "monthly_window_start" field in the mutation.
func (m *UserSubscriptionMutation) MonthlyWindowStart() (r time.Time, exists bool) {
	v := m.monthly_window_start
	if v == nil {
		return
	}
	return *v, true
}

// OldMonthlyWindowStart returns the old "monthly_window_start" field's value of the UserSubscription entity.
// If the UserSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSubscriptionMutation) OldMonthlyWindowStart(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMonthlyWindowStart is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMonthlyWindowStart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMonthlyWindowStart: %w", err)
	}
	return oldValue.MonthlyWindowStart, nil
}

// ClearMonthlyWindowStart clears the value of the "monthly_window_start" field.
func (m *UserSubscriptionMutation) ClearMonthlyWindowStart() {
	m.monthly_window_start = nil
	m.clearedFields[usersubscription.FieldMonthlyWindowStart] = struct{}{}
}

// MonthlyWindowStartCleared returns if the "monthly_window_start" field was cleared in this mutation.
func (m *UserSubscriptionMutation) MonthlyWindowStartCleared() bool {
	_, ok := m.clearedFields[usersubscription.FieldMonthlyWindowStart]
	return ok
}

// ResetMonthlyWindowStart resets all changes to the "monthly_window_start" field.
func (m *UserSubscriptionMutation) ResetMonthlyWindowStart() {
	m.monthly_window_start = nil
	delete(m.clearedFields, usersubscription.FieldMonthlyWindowStart)
}

// SetDailyUsageUsd sets the "daily_usage_usd" field.
func (m *UserSubscriptionMutation) SetDailyUsageUsd(f float64) {
	m.daily_usage_usd = &f
	m.adddaily_usage_usd = nil
}

// DailyUsageUsd returns the value of the "daily_usage_usd" field in the mutation.
func (m *UserSubscriptionMutation) DailyUsageUsd() (r float64, exists bool) {
	v := m.daily_usage_usd
	if v == nil {
		return
	}
	return *v, true
}

// OldDailyUsageUsd returns the old "daily_usage_usd" field's value of the UserSubscription entity.
// If the UserSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSubscriptionMutation) OldDailyUsageUsd(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDailyUsageUsd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDailyUsageUsd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDailyUsageUsd: %w", err)
	}
	return oldValue.DailyUsageUsd, nil
}

// AddDailyUsageUsd adds f to the "daily_usage_usd" field.
func (m *UserSubscriptionMutation) AddDailyUsageUsd(f float64) {
	if m.adddaily_usage_usd != nil {
		*m.adddaily_usage_usd += f
	} else {
		m.adddaily_usage_usd = &f
	}
}

// AddedDailyUsageUsd returns the value that was added to the "daily_usage_usd" field in this mutation.
func (m *UserSubscriptionMutation) AddedDailyUsageUsd() (r float64, exists bool) {
	v := m.adddaily_usage_usd
	if v == nil {
		return
	}
	return *v, true
}

// ResetDailyUsageUsd resets all changes to the "daily_usage_usd" field.
func (m *UserSubscriptionMutation) ResetDailyUsageUsd() {
	m.daily_usage_usd = nil
	m.adddaily_usage_usd = nil
}

// SetWeeklyUsageUsd sets the "weekly_usage_usd" field.
func (m *UserSubscriptionMutation) SetWeeklyUsageUsd(f float64) {
	m.weekly_usage_usd = &f
	m.addweekly_usage_usd = nil
}

// WeeklyUsageUsd returns the value of the "weekly_usage_usd" field in the mutation.
func (m *UserSubscriptionMutation) WeeklyUsageUsd() (r float64, exists bool) {
	v := m.weekly_usage_usd
	if v == nil {
		return
	}
	return *v, true
}

// OldWeeklyUsageUsd returns the old "weekly_usage_usd" field's value of the UserSubscription entity.
// If the UserSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSubscriptionMutation) OldWeeklyUsageUsd(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWeeklyUsageUsd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWeeklyUsageUsd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWeeklyUsageUsd: %w", err)
	}
	return oldValue.WeeklyUsageUsd, nil
}

// AddWeeklyUsageUsd adds f to the "weekly_usage_usd" field.
func (m *UserSubscriptionMutation) AddWeeklyUsageUsd(f float64) {
	if m.addweekly_usage_usd != nil {
		*m.addweekly_usage_usd += f
	} else {
		m.addweekly_usage_usd = &f
	}
}

// AddedWeeklyUsageUsd returns the value that was added to the "weekly_usage_usd" field in this mutation.
func (m *UserSubscriptionMutation) AddedWeeklyUsageUsd() (r float64, exists bool) {
	v := m.addweekly_usage_usd
	if v == nil {
		return
	}
	return *v, true
}

// ResetWeeklyUsageUsd resets all changes to the "weekly_usage_usd" field.
func (m *UserSubscriptionMutation) ResetWeeklyUsageUsd() {
	m.weekly_usage_usd = nil
	m.addweekly_usage_usd = nil
}

// SetMonthlyUsageUsd sets the "monthly_usage_usd" field.
func (m *UserSubscriptionMutation) SetMonthlyUsageUsd(f float64) {
	m.monthly_usage_usd = &f
	m.addmonthly_usage_usd = nil
}

// MonthlyUsageUsd returns the value of the "monthly_usage_usd" field in the mutation.
func (m *UserSubscriptionMutation) MonthlyUsageUsd() (r float64, exists bool) {
	v := m.monthly_usage_usd
	if v == nil {
		return
	}
	return *v, true
}

// OldMonthlyUsageUsd returns the old "monthly_usage_usd" field's value of the UserSubscription entity.
// If the UserSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSubscriptionMutation) OldMonthlyUsageUsd(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMonthlyUsageUsd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMonthlyUsageUsd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMonthlyUsageUsd: %w", err)
	}
	return oldValue.MonthlyUsageUsd, nil
}

// AddMonthlyUsageUsd adds f to the "monthly_usage_usd" field.
func (m *UserSubscriptionMutation) AddMonthlyUsageUsd(f float64) {
	if m.addmonthly_usage_usd != nil {
		*m.addmonthly_usage_usd += f
	} else {
		m.addmonthly_usage_usd = &f
	}
}

// AddedMonthlyUsageUsd returns the value that was added to the "monthly_usage_usd" field in this mutation.
func (m *UserSubscriptionMutation) AddedMonthlyUsageUsd() (r float64, exists bool) {
	v := m.addmonthly_usage_usd
	if v == nil {
		return
	}
	return *v, true
}

// ResetMonthlyUsageUsd resets all changes to the "monthly_usage_usd" field.
func (m *UserSubscriptionMutation) ResetMonthlyUsageUsd() {
	m.monthly_usage_usd = nil
	m.addmonthly_usage_usd = nil
}

// SetAssignedBy sets the "assigned_by" field.
func (m *UserSubscriptionMutation) SetAssignedBy(i int64) {
	m.assigned_by_user = &i
}

// AssignedBy returns the value of the "assigned_by" field in the mutation.
func (m *UserSubscriptionMutation) AssignedBy() (r int64, exists bool) {
	v := m.assigned_by_user
	if v == nil {
		return
	}
	return *v, true
}

// OldAssignedBy returns the old "assigned_by" field's value of the UserSubscription entity.
// If the UserSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSubscriptionMutation) OldAssignedBy(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssignedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssignedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssignedBy: %w", err)
	}
	return oldValue.AssignedBy, nil
}

// ClearAssignedBy clears the value of the "assigned_by" field.
func (m *UserSubscriptionMutation) ClearAssignedBy() {
	m.assigned_by_user = nil
	m.clearedFields[usersubscription.FieldAssignedBy] = struct{}{}
}

// AssignedByCleared returns if the "assigned_by" field was cleared in this mutation.
func (m *UserSubscriptionMutation) AssignedByCleared() bool {
	_, ok := m.clearedFields[usersubscription.FieldAssignedBy]
	return ok
}

// ResetAssignedBy resets all changes to the "assigned_by" field.
func (m *UserSubscriptionMutation) ResetAssignedBy() {
	m.assigned_by_user = nil
	delete(m.clearedFields, usersubscription.FieldAssignedBy)
}

// SetAssignedAt sets the "assigned_at" field.
func (m *UserSubscriptionMutation) SetAssignedAt(t time.Time) {
	m.assigned_at = &t
}

// AssignedAt returns the value of the "assigned_at" field in the mutation.
func (m *UserSubscriptionMutation) AssignedAt() (r time.Time, exists bool) {
	v := m.assigned_at
	if v == nil {
		return
	}
	return *v, true
}

// OldAssignedAt returns the old "assigned_at" field's value of the UserSubscription entity.
// If the UserSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSubscriptionMutation) OldAssignedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssignedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssignedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssignedAt: %w", err)
	}
	return oldValue.AssignedAt, nil
}

// ResetAssignedAt resets all changes to the "assigned_at" field.
func (m *UserSubscriptionMutation) ResetAssignedAt() {
	m.assigned_at = nil
}

// SetNotes sets the "notes" field.
func (m *UserSubscriptionMutation) SetNotes(s string) {
	m.notes = &s
}

// Notes returns the value of the "notes" field in the mutation.
func (m *UserSubscriptionMutation) Notes() (r string, exists bool) {
	v := m.notes
	if v == nil {
		return
	}
	return *v, true
}

// OldNotes returns the old "notes" field's value of the UserSubscription entity.
// If the UserSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSubscriptionMutation) OldNotes(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotes: %w", err)
	}
	return oldValue.Notes, nil
}

// ClearNotes clears the value of the "notes" field.
func (m *UserSubscriptionMutation) ClearNotes() {
	m.notes = nil
	m.clearedFields[usersubscription.FieldNotes] = struct{}{}
}

// NotesCleared returns if the "notes" field was cleared in this mutation.
func (m *UserSubscriptionMutation) NotesCleared() bool {
	_, ok := m.clearedFields[usersubscription.FieldNotes]
	return ok
}

// ResetNotes resets all changes to the "notes" field.
func (m *UserSubscriptionMutation) ResetNotes() {
	m.notes = nil
	delete(m.clearedFields, usersubscription.FieldNotes)
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserSubscriptionMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[usersubscription.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserSubscriptionMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserSubscriptionMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserSubscriptionMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearGroup clears the "group" edge to the Group entity.
func (m *UserSubscriptionMutation) ClearGroup() {
	m.clearedgroup = true
	m.clearedFields[usersubscription.FieldGroupID] = struct{}{}
}

// GroupCleared reports if the "group" edge to the Group entity was cleared.
func (m *UserSubscriptionMutation) GroupCleared() bool {
	return m.clearedgroup
}

// GroupIDs returns the "group" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GroupID instead. It exists only for internal usage by the builders.
func (m *UserSubscriptionMutation) GroupIDs() (ids []int64) {
	if id := m.group; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGroup resets all changes to the "group" edge.
func (m *UserSubscriptionMutation) ResetGroup() {
	m.group = nil
	m.clearedgroup = false
}

// SetAssignedByUserID sets the "assigned_by_user" edge to the User entity by id.
func (m *UserSubscriptionMutation) SetAssignedByUserID(id int64) {
	m.assigned_by_user = &id
}

// ClearAssignedByUser clears the "assigned_by_user" edge to the User entity.
func (m *UserSubscriptionMutation) ClearAssignedByUser() {
	m.clearedassigned_by_user = true
	m.clearedFields[usersubscription.FieldAssignedBy] = struct{}{}
}

// AssignedByUserCleared reports if the "assigned_by_user" edge to the User entity was cleared.
func (m *UserSubscriptionMutation) AssignedByUserCleared() bool {
	return m.AssignedByCleared() || m.clearedassigned_by_user
}

// AssignedByUserID returns the "assigned_by_user" edge ID in the mutation.
func (m *UserSubscriptionMutation) AssignedByUserID() (id int64, exists bool) {
	if m.assigned_by_user != nil {
		return *m.assigned_by_user, true
	}
	return
}

// AssignedByUserIDs returns the "assigned_by_user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AssignedByUserID instead. It exists only for internal usage by the builders.
func (m *UserSubscriptionMutation) AssignedByUserIDs() (ids []int64) {
	if id := m.assigned_by_user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAssignedByUser resets all changes to the "assigned_by_user" edge.
func (m *UserSubscriptionMutation) ResetAssignedByUser() {
	m.assigned_by_user = nil
	m.clearedassigned_by_user = false
}

// Where appends a list predicates to the UserSubscriptionMutation builder.
func (m *UserSubscriptionMutation) Where(ps ...predicate.UserSubscription) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserSubscriptionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserSubscriptionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserSubscription, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserSubscriptionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserSubscriptionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserSubscription).
func (m *UserSubscriptionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserSubscriptionMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.created_at != nil {
		fields = append(fields, usersubscription.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, usersubscription.FieldUpdatedAt)
	}
	if m.user != nil {
		fields = append(fields, usersubscription.FieldUserID)
	}
	if m.group != nil {
		fields = append(fields, usersubscription.FieldGroupID)
	}
	if m.starts_at != nil {
		fields = append(fields, usersubscription.FieldStartsAt)
	}
	if m.expires_at != nil {
		fields = append(fields, usersubscription.FieldExpiresAt)
	}
	if m.status != nil {
		fields = append(fields, usersubscription.FieldStatus)
	}
	if m.daily_window_start != nil {
		fields = append(fields, usersubscription.FieldDailyWindowStart)
	}
	if m.weekly_window_start != nil {
		fields = append(fields, usersubscription.FieldWeeklyWindowStart)
	}
	if m.monthly_window_start != nil {
		fields = append(fields, usersubscription.FieldMonthlyWindowStart)
	}
	if m.daily_usage_usd != nil {
		fields = append(fields, usersubscription.FieldDailyUsageUsd)
	}
	if m.weekly_usage_usd != nil {
		fields = append(fields, usersubscription.FieldWeeklyUsageUsd)
	}
	if m.monthly_usage_usd != nil {
		fields = append(fields, usersubscription.FieldMonthlyUsageUsd)
	}
	if m.assigned_by_user != nil {
		fields = append(fields, usersubscription.FieldAssignedBy)
	}
	if m.assigned_at != nil {
		fields = append(fields, usersubscription.FieldAssignedAt)
	}
	if m.notes != nil {
		fields = append(fields, usersubscription.FieldNotes)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserSubscriptionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case usersubscription.FieldCreatedAt:
		return m.CreatedAt()
	case usersubscription.FieldUpdatedAt:
		return m.UpdatedAt()
	case usersubscription.FieldUserID:
		return m.UserID()
	case usersubscription.FieldGroupID:
		return m.GroupID()
	case usersubscription.FieldStartsAt:
		return m.StartsAt()
	case usersubscription.FieldExpiresAt:
		return m.ExpiresAt()
	case usersubscription.FieldStatus:
		return m.Status()
	case usersubscription.FieldDailyWindowStart:
		return m.DailyWindowStart()
	case usersubscription.FieldWeeklyWindowStart:
		return m.WeeklyWindowStart()
	case usersubscription.FieldMonthlyWindowStart:
		return m.MonthlyWindowStart()
	case usersubscription.FieldDailyUsageUsd:
		return m.DailyUsageUsd()
	case usersubscription.FieldWeeklyUsageUsd:
		return m.WeeklyUsageUsd()
	case usersubscription.FieldMonthlyUsageUsd:
		return m.MonthlyUsageUsd()
	case usersubscription.FieldAssignedBy:
		return m.AssignedBy()
	case usersubscription.FieldAssignedAt:
		return m.AssignedAt()
	case usersubscription.FieldNotes:
		return m.Notes()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserSubscriptionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case usersubscription.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case usersubscription.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case usersubscription.FieldUserID:
		return m.OldUserID(ctx)
	case usersubscription.FieldGroupID:
		return m.OldGroupID(ctx)
	case usersubscription.FieldStartsAt:
		return m.OldStartsAt(ctx)
	case usersubscription.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case usersubscription.FieldStatus:
		return m.OldStatus(ctx)
	case usersubscription.FieldDailyWindowStart:
		return m.OldDailyWindowStart(ctx)
	case usersubscription.FieldWeeklyWindowStart:
		return m.OldWeeklyWindowStart(ctx)
	case usersubscription.FieldMonthlyWindowStart:
		return m.OldMonthlyWindowStart(ctx)
	case usersubscription.FieldDailyUsageUsd:
		return m.OldDailyUsageUsd(ctx)
	case usersubscription.FieldWeeklyUsageUsd:
		return m.OldWeeklyUsageUsd(ctx)
	case usersubscription.FieldMonthlyUsageUsd:
		return m.OldMonthlyUsageUsd(ctx)
	case usersubscription.FieldAssignedBy:
		return m.OldAssignedBy(ctx)
	case usersubscription.FieldAssignedAt:
		return m.OldAssignedAt(ctx)
	case usersubscription.FieldNotes:
		return m.OldNotes(ctx)
	}
	return nil, fmt.Errorf("unknown UserSubscription field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserSubscriptionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case usersubscription.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case usersubscription.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case usersubscription.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case usersubscription.FieldGroupID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroupID(v)
		return nil
	case usersubscription.FieldStartsAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartsAt(v)
		return nil
	case usersubscription.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case usersubscription.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case usersubscription.FieldDailyWindowStart:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDailyWindowStart(v)
		return nil
	case usersubscription.FieldWeeklyWindowStart:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWeeklyWindowStart(v)
		return nil
	case usersubscription.FieldMonthlyWindowStart:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMonthlyWindowStart(v)
		return nil
	case usersubscription.FieldDailyUsageUsd:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDailyUsageUsd(v)
		return nil
	case usersubscription.FieldWeeklyUsageUsd:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWeeklyUsageUsd(v)
		return nil
	case usersubscription.FieldMonthlyUsageUsd:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMonthlyUsageUsd(v)
		return nil
	case usersubscription.FieldAssignedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssignedBy(v)
		return nil
	case usersubscription.FieldAssignedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssignedAt(v)
		return nil
	case usersubscription.FieldNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotes(v)
		return nil
	}
	return fmt.Errorf("unknown UserSubscription field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserSubscriptionMutation) AddedFields() []string {
	var fields []string
	if m.adddaily_usage_usd != nil {
		fields = append(fields, usersubscription.FieldDailyUsageUsd)
	}
	if m.addweekly_usage_usd != nil {
		fields = append(fields, usersubscription.FieldWeeklyUsageUsd)
	}
	if m.addmonthly_usage_usd != nil {
		fields = append(fields, usersubscription.FieldMonthlyUsageUsd)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserSubscriptionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case usersubscription.FieldDailyUsageUsd:
		return m.AddedDailyUsageUsd()
	case usersubscription.FieldWeeklyUsageUsd:
		return m.AddedWeeklyUsageUsd()
	case usersubscription.FieldMonthlyUsageUsd:
		return m.AddedMonthlyUsageUsd()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserSubscriptionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case usersubscription.FieldDailyUsageUsd:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDailyUsageUsd(v)
		return nil
	case usersubscription.FieldWeeklyUsageUsd:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWeeklyUsageUsd(v)
		return nil
	case usersubscription.FieldMonthlyUsageUsd:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMonthlyUsageUsd(v)
		return nil
	}
	return fmt.Errorf("unknown UserSubscription numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserSubscriptionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(usersubscription.FieldDailyWindowStart) {
		fields = append(fields, usersubscription.FieldDailyWindowStart)
	}
	if m.FieldCleared(usersubscription.FieldWeeklyWindowStart) {
		fields = append(fields, usersubscription.FieldWeeklyWindowStart)
	}
	if m.FieldCleared(usersubscription.FieldMonthlyWindowStart) {
		fields = append(fields, usersubscription.FieldMonthlyWindowStart)
	}
	if m.FieldCleared(usersubscription.FieldAssignedBy) {
		fields = append(fields, usersubscription.FieldAssignedBy)
	}
	if m.FieldCleared(usersubscription.FieldNotes) {
		fields = append(fields, usersubscription.FieldNotes)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserSubscriptionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserSubscriptionMutation) ClearField(name string) error {
	switch name {
	case usersubscription.FieldDailyWindowStart:
		m.ClearDailyWindowStart()
		return nil
	case usersubscription.FieldWeeklyWindowStart:
		m.ClearWeeklyWindowStart()
		return nil
	case usersubscription.FieldMonthlyWindowStart:
		m.ClearMonthlyWindowStart()
		return nil
	case usersubscription.FieldAssignedBy:
		m.ClearAssignedBy()
		return nil
	case usersubscription.FieldNotes:
		m.ClearNotes()
		return nil
	}
	return fmt.Errorf("unknown UserSubscription nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserSubscriptionMutation) ResetField(name string) error {
	switch name {
	case usersubscription.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case usersubscription.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case usersubscription.FieldUserID:
		m.ResetUserID()
		return nil
	case usersubscription.FieldGroupID:
		m.ResetGroupID()
		return nil
	case usersubscription.FieldStartsAt:
		m.ResetStartsAt()
		return nil
	case usersubscription.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case usersubscription.FieldStatus:
		m.ResetStatus()
		return nil
	case usersubscription.FieldDailyWindowStart:
		m.ResetDailyWindowStart()
		return nil
	case usersubscription.FieldWeeklyWindowStart:
		m.ResetWeeklyWindowStart()
		return nil
	case usersubscription.FieldMonthlyWindowStart:
		m.ResetMonthlyWindowStart()
		return nil
	case usersubscription.FieldDailyUsageUsd:
		m.ResetDailyUsageUsd()
		return nil
	case usersubscription.FieldWeeklyUsageUsd:
		m.ResetWeeklyUsageUsd()
		return nil
	case usersubscription.FieldMonthlyUsageUsd:
		m.ResetMonthlyUsageUsd()
		return nil
	case usersubscription.FieldAssignedBy:
		m.ResetAssignedBy()
		return nil
	case usersubscription.FieldAssignedAt:
		m.ResetAssignedAt()
		return nil
	case usersubscription.FieldNotes:
		m.ResetNotes()
		return nil
	}
	return fmt.Errorf("unknown UserSubscription field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserSubscriptionMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.user != nil {
		edges = append(edges, usersubscription.EdgeUser)
	}
	if m.group != nil {
		edges = append(edges, usersubscription.EdgeGroup)
	}
	if m.assigned_by_user != nil {
		edges = append(edges, usersubscription.EdgeAssignedByUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserSubscriptionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case usersubscription.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case usersubscription.EdgeGroup:
		if id := m.group; id != nil {
			return []ent.Value{*id}
		}
	case usersubscription.EdgeAssignedByUser:
		if id := m.assigned_by_user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserSubscriptionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserSubscriptionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserSubscriptionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleareduser {
		edges = append(edges, usersubscription.EdgeUser)
	}
	if m.clearedgroup {
		edges = append(edges, usersubscription.EdgeGroup)
	}
	if m.clearedassigned_by_user {
		edges = append(edges, usersubscription.EdgeAssignedByUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserSubscriptionMutation) EdgeCleared(name string) bool {
	switch name {
	case usersubscription.EdgeUser:
		return m.cleareduser
	case usersubscription.EdgeGroup:
		return m.clearedgroup
	case usersubscription.EdgeAssignedByUser:
		return m.clearedassigned_by_user
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserSubscriptionMutation) ClearEdge(name string) error {
	switch name {
	case usersubscription.EdgeUser:
		m.ClearUser()
		return nil
	case usersubscription.EdgeGroup:
		m.ClearGroup()
		return nil
	case usersubscription.EdgeAssignedByUser:
		m.ClearAssignedByUser()
		return nil
	}
	return fmt.Errorf("unknown UserSubscription unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserSubscriptionMutation) ResetEdge(name string) error {
	switch name {
	case usersubscription.EdgeUser:
		m.ResetUser()
		return nil
	case usersubscription.EdgeGroup:
		m.ResetGroup()
		return nil
	case usersubscription.EdgeAssignedByUser:
		m.ResetAssignedByUser()
		return nil
	}
	return fmt.Errorf("unknown UserSubscription edge %s", name)
}
